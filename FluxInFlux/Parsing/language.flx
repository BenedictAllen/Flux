
namespace Flux::Parsing::language;

let _ = (function() {
	Flux::Parsing::language::valid_native_operators = {
		["and"] = true, ["or"] = true;

		["andeq"] = true, ["oreq"] = true;

		["add"] = true, ["sub"] = true;
		["mul"] = true, ["div"] = true;
		["mod"] = true, ["pow"] = true;

		["addeq"] = true, ["subeq"] = true;
		["muleq"] = true, ["diveq"] = true;
		["modeq"] = true, ["poweq"] = true;

		["blshift"] = true, ["brshift"] = true;
		["band"] = true, ["bor"] = true, ["bxor"] = true;

		["blshifteq"] = true, ["brshifteq"] = true;
		["bandeq"] = true, ["boreq"] = true, ["bxoreq"] = true;

		["gt"] = true, ["gte"] = true;
		["lt"] = true, ["lte"] = true;
		["eq"] = true, ["neq"] = true;

		["unm"] = true;
		["bnot"] = true;
		["len"] = true;
		["not"] = true;

		["concat"] = true;
	};

	Flux::Parsing::language::keyword_str = "

	import

	namespace
	using
	class extends implements
	interface implements
	enum

	final abstract
	public private static
	setter getter
	operator

	if else
	while
	repeat until while
	do
	for
	foreach in

	switch case default
	try catch default
	new
	return break continue
	let const where
	template const auto void

	throw
	typeof
	function
	lambda
	match

	then

	null
	";

	// the operator '>>', '>=' and '>>=' aren't listed below as they would interfere with templates:
	// 'vector<Buffer<T>>'
	// note the '>>' on the end

	Flux::Parsing::language::operator_str = "
	++ -- # ! ~

	= += -= *= /= %= **= &= |= ^= <<= &&= ||=

	||
	&&
	> < <= == !=
	..
	|
	&
	^
	<<
	+ -
	* / %
	**

	";

	Flux::Parsing::language::symbol_str = "
	( )
	{ }
	[ ]

	=>
	->

	. :
	,
	;

	...
	::
	@

	";

	do { // register the keywords
		let text = Flux::Parsing::language::keyword_str;
		let found = [text:find "%w+"];

		while found[1]
			Flux::Parsing::language::keywords[text:sub( found[1], found[2] )] = true;
			then found = [text:find( "%w+", found[2] + 1 )];
	}

	do { // register the operators
		let text = Flux::Parsing::language::operator_str;
		let found = [text:find "[^\n]+"];

		while found[1] {
			let line = text:sub( found[1], found[2] );
			let found_line = [line:find "%S+"];

			while found_line[1] {
				let op = line:sub( found_line[1], found_line[2] );
				
				Flux::Parsing::language::symbols[op] = true;
				Flux::Parsing::language::operators[op] = true;

				switch Flux::Parsing::language::precedence;
				case 0
					Flux::Parsing::language::unary_operators[op] = true;
				default
					Flux::Parsing::language::binary_operators[op] = Flux::Parsing::language::precedence;

				found_line = [line:find( "%S+", found_line[2] + 1 )];
			}

			Flux::Parsing::language::precedence++;
			found = [text:find( "[^\n]+", found[2] + 1 )];
		}
	}

	do { // register the other symbols
		let text = Flux::Parsing::language::symbol_str;
		let found = [text:find "%S+"];

		while found[1]
			Flux::Parsing::language::symbols[text:sub( found[1], found[2] )] = true;
			then found = [text:find( "%S+", found[2] + 1 )];
	}

	// add precedences for the operators that couldn't be listed
	Flux::Parsing::language::binary_operators[">>"] = Flux::Parsing::language::binary_operators["<<"];
	Flux::Parsing::language::binary_operators[">="] = Flux::Parsing::language::binary_operators["<="];
	Flux::Parsing::language::binary_operators[">>="] = Flux::Parsing::language::binary_operators["<<="];
	Flux::Parsing::language::operators[">>"] = true;
	Flux::Parsing::language::operators[">="] = true;
	Flux::Parsing::language::operators[">>="] = true;

	// define '-' and '^' as an unary operator as well as binary
	Flux::Parsing::language::unary_operators["-"] = true;
	Flux::Parsing::language::unary_operators["^"] = true;

})();
