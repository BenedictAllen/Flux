
namespace Flux::Parsing::language;

let keywords -> bool{string} = [];
let binary_operators -> int{string} = [];
let unary_operators -> bool{string} = [];
let symbols -> bool{string} = [];

let keyword_str = "

import

namespace
using
class extends implements
interface implements
enum

public private static
setter getter
operator

if else
while
repeat until while
do
for
foreach in

switch case default
try catch default
new
return break continue
let const where
template const auto void

throw
typeof
function
lambda
match

then

"/*and or*/ `concat` "

null
";

// the operator '>>' isn't listed below as it would interfere with templates 'vector<Buffer<T>>' (note the '>>' on the end)

let operator_str = "
++ -- # ! ~

= += -= *= /= %= **= &= |= ^= <<= >>=

||
&&
> < >= <= == !=
..
|
&
^
<<
+ -
* / %
**

";

let symbol_str = "
( )
{ }
[ ]

=>
->

. :
,
;

...
::
@

";

let precedence = 0;

let _ = (function() { // this is hacky :/
	let text = Flux::Parsing::language::keyword_str;
	let found = [text:find "%w+"];

	while found[1]
		Flux::Parsing::language::keywords[text:sub( found[1], found[2] )] = true;
		then found = [text:find( "%w+", found[2] + 1 )];
}) ();

let _ = (function() { // this is hacky too :/
	let text = Flux::Parsing::language::operator_str;
	let found = [text:find "[^\n]+"];

	while found[1] {
		let line = text:sub( found[1], found[2] );
		let found_line = [line:find "%S+"];

		while found_line[1] {
			let op = line:sub( found_line[1], found_line[2] );
			
			Flux::Parsing::language::symbols[op] = true;

			switch Flux::Parsing::language::precedence;
			case 0
				Flux::Parsing::language::unary_operators[op] = true;
			default
				Flux::Parsing::language::binary_operators[op] = Flux::Parsing::language::precedence;

			found_line = [line:find( "%S+", found_line[2] + 1 )];
		}

		Flux::Parsing::language::precedence++;
		found = [text:find( "[^\n]+", found[2] + 1 )];
	}

	Flux::Parsing::language::unary_operators["-"] = true;
}) ();

let _ = (function() { // this is also hacky :/
	let text = Flux::Parsing::language::symbol_str;
	let found = [text:find "%S+"];

	while found[1]
		Flux::Parsing::language::symbols[text:sub( found[1], found[2] )] = true;
		then found = [text:find( "%S+", found[2] + 1 )];
}) ();

let _ = (function() {
	Flux::Parsing::language::binary_operators[">>"] = Flux::Parsing::language::binary_operators["<<"];
}) ();
