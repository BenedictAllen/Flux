
namespace Flux::Parsing;

void Source:setup_file(string name, string path, string extension) {
	if !self.files_included[path]
		self.files_included[path] = new Flux::Parsing::File( name, path );

	if self.file
		self.file:add_import( self.files_included[path] );

	self.file = self.files_included[path];
	self.files[#self.files + 1] = self.file;

	self.file:initialise_lexer( Flux::read_file( path `concat` extension ) );
	self.lexer = self.file.lexer;
	self.current_include_path[#self.current_include_path + 1] = string__match( path, ".+/" ) || "/";
}

void Source:parse_content() {
	while self.lexer:test( Keyword, "import" )
		Flux::Parsing::ImportStatement:parse( self );

	while !self.lexer:isEOF()
		Flux::Parsing::Statement:parse( self );
}

void Source:close_file() {
	self.files[#self.files] = null;
	self.file = self.files[#self.files];
	self.lexer = self.file && self.file.lexer;
	self.current_include_path[#self.current_include_path] = null;
}

bool Source:import_file(string name) {
	string filename = name:gsub( "%.", "/" );
	string[] paths_to_check = [];

	do { // calculate paths to check
		string path = self.environment["PATH"];
		string current_include_path = self.current_include_path[#self.current_include_path];
		int start_pos = 1;
		int end_pos = path:find ";";

		if current_include_path {
			int found_pos = current_include_path:find "/";

			while found_pos {
				table.insert( paths_to_check, 1, current_include_path:sub( 1, found_pos ) );
				found_pos = current_include_path:find( "/", found_pos + 1 );
			}
		}

		while end_pos {
			paths_to_check[#paths_to_check + 1] = path:sub( start_pos, end_pos - 1 );
			start_pos = end_pos + 1;
			end_pos = path:find( ";", end_pos + 1 );
		}

		paths_to_check[#paths_to_check + 1] = path:sub( start_pos );
	}

	foreach path in paths_to_check {
		string file_path = path `concat` "/" `concat` filename;

		if Flux::is_file( file_path `concat` ".flxh" ) {
			if !self.files_included[file_path] {
				self:setup_file( name, file_path, ".flxh" );
				self:parse_content();
				self:close_file();

				if Flux::is_file( file_path `concat` ".flx" ) {
					self:setup_file( name, file_path, ".flx" );
					self:parse_content();
					self:close_file();
				}
			}

			return true;
		}
		else if Flux::is_file( file_path `concat` ".flx" ) {
			if !self.files_included[file_path] {
				self:setup_file( name, file_path, ".flx" );
				self:parse_content();
				self:close_file();
			}

			return true;
		}
	}

	return false;
}

bool Source:import_project(string[] files) {
	while #files > 0 {
		if !self:import_file( files[1] )
			return false;

		table.remove( files, 1 );
	}

	return true;
}

void Source:error(string err, null Position position = self.lexer:get().position)
	= throw new ParserException(src `concat` "[" `concat` line `concat` "]: " `concat` err `concat` "\n\t"
		`concat` strline `concat` "\n\t"
		`concat` char_pointer)
	where src = position.source
	where line = position.line
	where strline = position.strline:gsub( "\t", " " )
	where char_pointer = (" "):rep( position.character - 1 ) `concat` "^";
