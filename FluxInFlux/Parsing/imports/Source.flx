
namespace Flux::Parsing;

void Source:setup_file(string name, string path, string extension) {
	self.file = new Flux::Parsing::File( name, path );
	self.files[#self.files + 1] = self.file;
	self.files_included[path] = self.file;

	self.file:initialise_lexer( Flux::read_file( path `concat` extension ) );
	self.lexer = self.file.lexer;
}

void Source:parse_content() {
	while self.lexer:test( Keyword, "import" )
		Flux::Parsing::ImportStatement:parse( self );

	while !self.lexer:isEOF()
		Flux::Parsing::Statement:parse( self );
}

void Source:close_file() {
	self.files[#self.files] = null;
	self.file = self.files[#self.files];
	self.lexer = self.file.lexer;
}

bool Source:import_file(string name) {
	string filename = name:gsub( "%.", "/" );
	string[] paths_to_check = [];

	do { // calculate paths to check
		string path = self.environment["PATH"];
		int start_pos = 1;
		int end_pos = path:find ";";

		while end_pos {
			paths_to_check[#paths_to_check + 1] = path:sub( start_pos, end_pos - 1 );
			start_pos = end_pos + 1;
			end_pos = path:find( ";", end_pos + 1 );
		}

		paths_to_check[#paths_to_check + 1] = path:sub( start_pos );
	}

	foreach path in paths_to_check {

	}

	// calculate paths to check
	// check all paths
	// if path found, import header and add source to queue
		// if no header, treat source as header
	// return false if not found
}

bool Source:import_project(string[] files) {
	repeat {
		if !self:import_file( files[1] )
			return false;

		table.remove( files, 1 );
	}
	until #files == 0;

	while self.import_queue[1] {
		let file = table.remove( self.import_queue, 1 );

		self:setup_file( self.import_queue_names[i], file, "flx" );
		self:parse_content();
		self:close_file();
	}

	return true;
}

void Source:error(string err, null Position position = self.lexer:get().position)
	= throw new ParserException(src `concat` "[" `concat` line `concat` "]: " `concat` err `concat` "\n\t"
		`concat` strline `concat` "\n\t"
		`concat` char_pointer)
	where src = position.source
	where line = position.line
	where strline = position.strline:gsub( "\t", " " )
	where char_pointer = (" "):rep( position.character - 1 ) `concat` "^";
