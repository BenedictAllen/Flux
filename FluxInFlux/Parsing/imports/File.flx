
namespace Flux::Parsing;

void File:initialise_lexer(string source_text) {
	self.lexer = new Flux::Parsing::Lexer( source_text, self.name, self.source );
	self.context = new Flux::Parsing::Context():specialise_root();

	self.contexts[1] = self.context;
}

void File:add_import(File file) {
	self.imports[#self.imports + 1] = file;
}

void File:define_type(TemplatedName type) {
	self.types[#self.types + 1] = type;
}

void File:push(ASTNode node) {
	if #self.blocks > 0
		self.blocks[#self.blocks]:push( node );
	else {
		if node typeof Flux::Parsing::EnumDefinition
			self:define_type( Type.ENUM, new Flux::Parsing::TemplatedName( node.name, [], node.position ) );

		if self.is_header
			self.header_statements[#self.header_statements + 1] = node;
		else
			self.statements[#self.statements + 1] = node;
	}
}

Context File:push_context() {
	new Flux::Parsing::Context context( self.context );

	self.context = context;
	self.contexts[#self.contexts + 1] = context;

	return context;
}

void File:pop_context() {
	self.contexts[#self.contexts] = null;
	self.context = self.contexts[#self.contexts];
}

void File:push_block(Position position, bool is_void) {
	self.blocks[#self.blocks + 1] = new Flux::Parsing::Block( is_void, position );
}

Block File:pop_block() {
	return table.remove( self.blocks, #self.blocks );
}
