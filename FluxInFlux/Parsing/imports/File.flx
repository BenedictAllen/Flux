
import definitions.Type;

namespace Flux::Parsing;

void File:initialise_lexer(string source_text) {
	self.lexer = new Flux::Parsing::Lexer( source_text, self.name, self.source );
	self.context = new Flux::Parsing::Context():specialise_root();

	self.contexts[1] = self.context;
}

void File:add_import(string file) {
	self.imports[#self.imports + 1] = file;
}

void File:define_type(Type t, TemplatedName name, bool is_public) {
	self.types[#self.types + 1] = { type = t, name = name, is_public = is_public };
}

void File:push(ASTNode node) {
	if #self.blocks > 0
		self.blocks[#self.blocks]:push( node );
	else {
		if self.is_header {
			if node typeof Flux::Parsing::EnumDefinition
				self:define_type( Flux::Parsing::Type.ENUM, new Flux::Parsing::TemplatedName( node.name, [], node.position ), node.is_public );

			self.header_statements[#self.header_statements + 1] = node;
		}
		else {
			if node typeof Flux::Parsing::EnumDefinition
				self:error( "enum must be defined in header file", node.position );

			self.statements[#self.statements + 1] = node;
		}
	}
}

Context File:push_context() {
	new Flux::Parsing::Context context( self.context );

	self.context = context;
	self.contexts[#self.contexts + 1] = context;

	return context;
}

void File:pop_context() {
	self.contexts[#self.contexts] = null;
	self.context = self.contexts[#self.contexts];
}

void File:push_block(Position position, bool is_void) {
	self.blocks[#self.blocks + 1] = new Flux::Parsing::Block( is_void, position );
}

Block File:pop_block() {
	return table.remove( self.blocks, #self.blocks );
}
