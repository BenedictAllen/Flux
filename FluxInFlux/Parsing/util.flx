
template<T>
string concattenate(T[] elements, null string seperator = "") {
	string[] s = [];

	foreach i, v in elements
		s[i] = v:serialize();

	return table.concat( s, seperator );
}

namespace Flux::Parsing;

bool parseSemicolon(Lexer lexer)
	= ((lexer:skip(Symbol, ";") || lexer:test(Symbol, ";", -1)) || lexer:test(Symbol, "}")) && true || false;

void expectSemicolon(Source source, null string location)
	if !Flux::Parsing::parseSemicolon( source.lexer )
		source:error( "expected ';'" `concat` (location && " at " `concat` location || "") );

bool tokenFollowsLast(Lexer lexer)
	= a.position.line == b.position.line && a.position.source == b.position.source && a.position.character + #a.value == b.position.character
	where a = lexer:peek( -1 )
	where b = lexer:get();

bool tokenSameLineAsLast(Lexer lexer)
	= a.position.line == b.position.line && a.position.source == b.position.source
	where a = lexer:peek( -1 )
	where b = lexer:get();

string parseName(Source source) {
	let name = source.lexer:skipValue(Identifier);

	while name && source.lexer:skip(Symbol, "::")
		name = name `concat` "::" `concat` (source.lexer:skipValue(Identifier) || source:error "expected name after ':'");

	return name;
}

string parseMethodName(Source source) {
	let lexer = source.lexer;

	if lexer:skip( Keyword, "operator" ) {
		if lexer:test( Symbol, "(" ) {
			return "()";
		}
		else if lexer:skip( Symbol, "[" ) {
			if !lexer:skip( Symbol, "]" ) source:error "expected ']' after '['";
			return lexer:skip( Symbol, "=" ) && "[]=" || "[]";
		}
		else {
			let symbol = lexer:skip( Symbol );
			let op = symbol && symbol.value;
			
			if op == ">" && Flux::Parsing::tokenFollowsLast(lexer) && lexer:skip( Symbol, ">" )
				op = ">>";

			if (op == ">" || op == ">>") && Flux::Parsing::tokenFollowsLast(lexer) && lexer:skip( Symbol, "=" )
				op = op `concat` "=";

			if Flux::Parsing::language::operators[op] {
				return op;
			}
			else {
				source:error( "expected operator after 'operator'", symbol && symbol.position );
			}
		}
	}
	else if source.context.isClass || source.context.isInterface // setters and getters might not be allowed in interfaces...
		if lexer:skip( Keyword, "setter" )
			return "setter " `concat` (lexer:skipValue( Identifier ) || source:error "expected name after 'setter'");
		else if lexer:skip( Keyword, "getter" )
			return "getter " `concat` (lexer:skipValue( Identifier ) || source:error "expected name after 'getter'");

	return lexer:skipValue( Identifier );
}

string parseInstructionOperand( Lexer lexer ) {
	string s = lexer:skipValue( String ) || lexer:skipValue( Character ) || lexer:skipValue( Float ) || lexer:skipValue( Integer ) || lexer:skipValue( Byte ) || lexer:skipValue( Hexadecimal ) || lexer:skipValue( Binary ) || lexer:skipValue( Boolean ) || lexer:skipValue( Null );
	if s return s;
	s = lexer:skipValue( Identifier );
	if s {
		while (lexer:test( Symbol, "-" ) || lexer:test( Symbol, "." ))
		   && (Flux::Parsing::tokenFollowsLast( lexer ))
		   && (lexer:test( Identifier, null, 1 ))
		   && (lexer:peek(1).position.character == lexer:get().position.character + 1)
			s = s `concat` lexer:next().value `concat` lexer:next().value;
		return s;
	}
}

string resolveDefinitionName( Source source, string name )
	= source.context.isNamespace && source.context.namespace_name && source.context.namespace_name `concat` "::" `concat` name || name;

string intToName( int n ) {
	string s = Flux::Parsing::letters[n % #Flux::Parsing::letters];

	while n > #Flux::Parsing::letters {
		n = math.floor( n / #Flux::Parsing::letters ) - 1;
		s = Flux::Parsing::letters[n % #Flux::Parsing::letters] .. s;
	}

	return s;
}

Block parseFunctionBody( Source source ) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	Block block;
	source:pushFunctionContext();

	if lexer:skip( Symbol, "=" ) {
		let expr = Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '='";
		Statement[] statements = [];

		while lexer:test( Keyword, "where" ) {
			Position position = lexer:next().position;
			string name = lexer:skipValue( Identifier ) || source:error "expected name after 'where'";
			Expression value;
			Typename _type = Flux::Parsing::Type:autoType( position );
			
			if lexer:skip( Symbol, "=" ) 
				value = Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '='";
			else
				source:error "expected '='";

			statements[#statements + 1] = new Flux::Parsing::Definition( _type, null, name, value, true, false, false, position );
		}

		statements[#statements + 1] = new Flux::Parsing::ReturnStatement( expr, position );

		if !Flux::Parsing::parseSemicolon(lexer)
			source:error "expected ';' after function return";

		block = new Flux::Parsing::Block( statements, position );
	}
	else
		block = Flux::Parsing::Block:parse( source );

	source:popContext();

	return block;
}

string serializeExpression(Expression e)
	= match e.type {
		Flux::Parsing::ASTNodeType.Reference,
		Flux::Parsing::ASTNodeType.IntegerConstant,
		Flux::Parsing::ASTNodeType.FloatConstant,
		Flux::Parsing::ASTNodeType.ByteConstant,
		Flux::Parsing::ASTNodeType.BooleanConstant,
		Flux::Parsing::ASTNodeType.NullConstant,
		Flux::Parsing::ASTNodeType.HexadecimalConstant,
		Flux::Parsing::ASTNodeType.BinaryConstant,
		Flux::Parsing::ASTNodeType.FunctionCall,
		Flux::Parsing::ASTNodeType.MethodCall,
		Flux::Parsing::ASTNodeType.Index,
		Flux::Parsing::ASTNodeType.DotIndex
			 => e:serialize();
		default => "(" `concat` e:serialize() `concat` ")";
	};

let _ = (function() {
	int n = 0;
	foreach i in string.byte "a" .. string.byte "z"
		Flux::Parsing::letters[n++] = string.char( i );

	foreach i in string.byte "A" .. string.byte "Z"
		Flux::Parsing::letters[n++] = string.char( i );
})();
