
template<T>
string concattenate(T[] elements, null string seperator = "") {
	string[] s = [];

	foreach i, v in elements
		s[i] = v:serialize();

	return table.concat( s, seperator );
}

namespace Flux::Parsing;

bool parseSemicolon(Lexer lexer)
	= ((lexer:skip(Symbol, ";") || lexer:test(Symbol, ";", -1)) || lexer:test(Symbol, "}")) && true || false;

string parseName(Source source) {
	let name = source.lexer:skipValue(Identifier);

	while name && source.lexer:skip(Symbol, "::")
		name = name `concat` "::" `concat` (source.lexer:skipValue(Identifier) || source:error "expected name after ':'");

	return name;
}

string parseMethodName(Source source) {
	let lexer = source.lexer;

	if lexer:skip(Keyword, "operator") {
		if lexer:skip(Symbol, "(") {
			error "Nope";
		}
		else if lexer:skip(Symbol, "[") {
			error "Nope";
		}
		else {
			let symbol = lexer:skip(Symbol);
			if symbol && Flux::Parsing::language::operators[symbol.value] {
				return symbol.value;
			}
			else {
				source:error "expected operator after 'operator'";
			}
		}
	}

	return lexer:skipValue(Identifier);
}

Block parseFunctionBody( Source source ) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	Block block;
	source:pushFunctionContext();

	if lexer:skip( Symbol, "=" ) {
		let expr = Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '='";
		Statement[] statements = [];

		while lexer:test( Keyword, "where" ) {
			Position position = lexer:next().position;
			string name = lexer:skipValue( Identifier ) || source:error "expected name after 'where'";
			Expression value;
			Typename _type = new Flux::Parsing::Typename( "auto", position );
			
			if lexer:skip( Symbol, "=" ) 
				value = Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '='";
			else
				source:error "expected '='";

			statements[#statements + 1] = new Flux::Parsing::Definition( _type, name, value, true, position );
		}

		statements[#statements + 1] = new Flux::Parsing::ReturnStatement( expr, position );

		if !Flux::Parsing::parseSemicolon(lexer)
			source:error "expected ';' after function return";

		block = new Flux::Parsing::Block( statements, position );
	}
	else
		block = Flux::Parsing::Block:parse( source );

	source:popContext();

	return block;
}

string serializeExpression(Expression e)
	= match e.type {
		Flux::Parsing::ASTNodeType.Reference,
		Flux::Parsing::ASTNodeType.IntegerConstant,
		Flux::Parsing::ASTNodeType.FloatConstant,
		Flux::Parsing::ASTNodeType.ByteConstant,
		Flux::Parsing::ASTNodeType.BooleanConstant,
		Flux::Parsing::ASTNodeType.NullConstant,
		Flux::Parsing::ASTNodeType.HexadecimalConstant,
		Flux::Parsing::ASTNodeType.BinaryConstant,
		Flux::Parsing::ASTNodeType.FunctionCall,
		Flux::Parsing::ASTNodeType.MethodCall,
		Flux::Parsing::ASTNodeType.Index,
		Flux::Parsing::ASTNodeType.DotIndex
			 => e:serialize();
		default => "(" `concat` e:serialize() `concat` ")";
	};
