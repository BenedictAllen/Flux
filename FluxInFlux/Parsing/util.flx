
template<T>
string concattenate(T[] elements, null string seperator = "") {
	string[] s = [];

	foreach i, v in elements
		s[i] = v:serialize();

	return table.concat( s, seperator );
}

namespace Flux::Parsing;

bool parseSemicolon(Lexer lexer)
	= (lexer:skip(Symbol, ";") || lexer:test(Symbol, ";", -1)) && true || false;

string parseName(Source source) {
	let name = source.lexer:skipValue(Identifier);

	while name && source.lexer:skip(Symbol, "::")
		name = name `concat` "::" `concat` (source.lexer:skipValue(Identifier) || source:error "expected name after ':'");

	return name;
}

string serializeExpression(Expression e)
	= match e.type {
		Flux::Parsing::ASTNodeType.Reference,
		Flux::Parsing::ASTNodeType.IntegerConstant,
		Flux::Parsing::ASTNodeType.FloatConstant,
		Flux::Parsing::ASTNodeType.ByteConstant,
		Flux::Parsing::ASTNodeType.BooleanConstant,
		Flux::Parsing::ASTNodeType.NullConstant,
		Flux::Parsing::ASTNodeType.HexadecimalConstant,
		Flux::Parsing::ASTNodeType.BinaryConstant,
		Flux::Parsing::ASTNodeType.FunctionCall,
		Flux::Parsing::ASTNodeType.MethodCall,
		Flux::Parsing::ASTNodeType.Index,
		Flux::Parsing::ASTNodeType.DotIndex
			 => e:serialize();
		default => "(" `concat` e:serialize() `concat` ")";
	};
