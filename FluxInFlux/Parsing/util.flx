
template<T>
string concattenate(T[] elements, null string seperator = "") {
	string[] s = [];

	foreach i, v in elements
		s[i] = v:serialize();

	return table.concat( s, seperator );
}

namespace Flux::Parsing;

bool parseSemicolon(Lexer lexer)
	= ((lexer:skip(Symbol, ";") || lexer:test(Symbol, ";", -1)) || lexer:test(Symbol, "}")) && true || false;

string parseName(Source source) {
	let name = source.lexer:skipValue(Identifier);

	while name && source.lexer:skip(Symbol, "::")
		name = name `concat` "::" `concat` (source.lexer:skipValue(Identifier) || source:error "expected name after ':'");

	return name;
}

string parseMethodName(Source source) {
	let lexer = source.lexer;

	if lexer:skip( Keyword, "operator" ) {
		if lexer:test( Symbol, "(" ) {
			return "()";
		}
		else if lexer:skip( Symbol, "[" ) {
			if !lexer:skip( Symbol, "]" ) source:error "expected ']' after '['";
			return lexer:skip( Symbol, "=" ) && "[]=" || "[]";
		}
		else {
			let symbol = lexer:skip( Symbol );
			let op = symbol && symbol.value;
			let ol = symbol && symbol.position.line, oc = symbol && symbol.position.character;
			
			if op == ">" && lexer:get().position.line == ol && lexer:get().position.character == oc + 1 && lexer:skip( Symbol, ">" ) {
				op = ">>";
				oc++;
			}

			if (op == ">" || op == ">>") && lexer:get().position.line == ol && lexer:get().position.character == oc + 1 && lexer:skip( Symbol, "=" )
				op = op `concat` "=";

			if Flux::Parsing::language::operators[op] {
				return op;
			}
			else {
				source:error( "expected operator after 'operator'", symbol && symbol.position );
			}
		}
	}
	else if source.context.isClass || source.context.isInterface // setters and getters might not be allowed in interfaces...
		if lexer:skip( Keyword, "setter" )
			return "setter " `concat` (lexer:skipValue( Identifier ) || source:error "expected name after 'setter'");
		else if lexer:skip( Keyword, "getter" )
			return "getter " `concat` (lexer:skipValue( Identifier ) || source:error "expected name after 'getter'");

	return lexer:skipValue( Identifier ) || source:error "expected name";
}

string resolveDefinitionName(Source source, string name)
	= source.context.isNamespace && source.context.namespace_name && source.context.namespace_name `concat` "::" `concat` name || name;

string intToName( int n ) {
	string s = Flux::Parsing::letters[n % #Flux::Parsing::letters];

	while n > #Flux::Parsing::letters {
		n = math.floor( n / #Flux::Parsing::letters ) - 1;
		s = Flux::Parsing::letters[n % #Flux::Parsing::letters] .. s;
	}

	return s;
}

Block parseFunctionBody( Source source ) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	Block block;
	source:pushFunctionContext();

	if lexer:skip( Symbol, "=" ) {
		let expr = Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '='";
		Statement[] statements = [];

		while lexer:test( Keyword, "where" ) {
			Position position = lexer:next().position;
			string name = lexer:skipValue( Identifier ) || source:error "expected name after 'where'";
			Expression value;
			Typename _type = new Flux::Parsing::Typename( "auto", position );
			
			if lexer:skip( Symbol, "=" ) 
				value = Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '='";
			else
				source:error "expected '='";

			statements[#statements + 1] = new Flux::Parsing::Definition( _type, null, name, value, true, false, false, position );
		}

		statements[#statements + 1] = new Flux::Parsing::ReturnStatement( expr, position );

		if !Flux::Parsing::parseSemicolon(lexer)
			source:error "expected ';' after function return";

		block = new Flux::Parsing::Block( statements, position );
	}
	else
		block = Flux::Parsing::Block:parse( source );

	source:popContext();

	return block;
}

string serializeExpression(Expression e)
	= match e.type {
		Flux::Parsing::ASTNodeType.Reference,
		Flux::Parsing::ASTNodeType.IntegerConstant,
		Flux::Parsing::ASTNodeType.FloatConstant,
		Flux::Parsing::ASTNodeType.ByteConstant,
		Flux::Parsing::ASTNodeType.BooleanConstant,
		Flux::Parsing::ASTNodeType.NullConstant,
		Flux::Parsing::ASTNodeType.HexadecimalConstant,
		Flux::Parsing::ASTNodeType.BinaryConstant,
		Flux::Parsing::ASTNodeType.FunctionCall,
		Flux::Parsing::ASTNodeType.MethodCall,
		Flux::Parsing::ASTNodeType.Index,
		Flux::Parsing::ASTNodeType.DotIndex
			 => e:serialize();
		default => "(" `concat` e:serialize() `concat` ")";
	};

let _ = (function() {
	int n = 0;
	foreach i in string.byte "a" .. string.byte "z"
		Flux::Parsing::letters[n++] = string.char( i );

	foreach i in string.byte "A" .. string.byte "Z"
		Flux::Parsing::letters[n++] = string.char( i );
})();
