
namespace Flux::Parsing;

string parseName(Source source) {
	let name = source.lexer:skipValue(Identifier);

	while name && source.lexer:skip(Symbol, "::")
		name = name `concat` "::" `concat` (source.lexer:skipValue(Identifier) || source:error "expected name after ':'");

	return name;
}

string serializeExpression(Expression e)
	= match e.type {
		Flux::Parsing::ASTNodeType.Reference,
		Flux::Parsing::ASTNodeType.IntegerConstant,
		Flux::Parsing::ASTNodeType.FloatConstant,
		Flux::Parsing::ASTNodeType.ByteConstant,
		Flux::Parsing::ASTNodeType.BooleanConstant,
		Flux::Parsing::ASTNodeType.NullConstant,
		Flux::Parsing::ASTNodeType.HexadecimalConstant,
		Flux::Parsing::ASTNodeType.BinaryConstant,
		Flux::Parsing::ASTNodeType.FunctionCall,
		Flux::Parsing::ASTNodeType.MethodCall,
		Flux::Parsing::ASTNodeType.Index,
		Flux::Parsing::ASTNodeType.DotIndex
			 => e:serialize();
		default => "(" `concat` e:serialize() `concat` ")";
	};
