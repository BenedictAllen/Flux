
import ASTNodeType;
import Position;

namespace Flux::Parsing;

class Block (ASTNode) extends ASTNode {
	ASTNodeType type = Flux::Parsing::ASTNodeType.Block;

	// void operator[]=(int index, ASTNode value) = self:__set__(index, value);
	// ASTNode operator[](int index) = self:__get__(index);
	// int operator#() = self:__len__();

	Block(ASTNode nodes, null Position position = nodes[1] && nodes[1].position)
		foreach i, node in nodes
			self[i] = node;
		then self.position = position;
}

string Block:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;
	
	source:pushBlock();

	if lexer:skip( Symbol, "{" ) {
		while !lexer:skip( Symbol, "}" ) {
			if lexer:isEOF() source:error "expected '}' to block";

			Flux::Parsing::Statement:parse(source);
		}
	}

	else {
		repeat
			Flux::Parsing::Statement:parse(source);
		while lexer:skip( Keyword, "then" );
	}

	let statements = source:popBlock();

	return new Flux::Parsing::Block( statements, position );
}

string Block:serialize()
	= match #self {
		0 => "{}";
		1 => "\n\t" `concat` self[1]:serialize():gsub( "\n", "\n\t" );
		default => "{\n\t" `concat` (self `concattenate` "\n"):gsub( "\n", "\n\t" ) `concat` "\n}";
	};
