
import TemplatedName;

namespace Flux::Parsing::types;

TemplatedName auto_type(Position position); // auto
TemplatedName void_type(Position position); // void
TemplatedName function_type(Position position, TemplatedName returns, TemplatedName[] parameters); // function
TemplatedName struct_type(Position position, string[] names, TemplatedName[] types); // struct
TemplatedName list_type(Position position, TemplatedName value); // List
TemplatedName table_type(Position position, TemplatedName value, TemplatedName index); // Table
TemplatedName reference_type(Position position, TemplatedName value); // Reference
TemplatedName nullable_type(Position position, TemplatedName value); // Option

TemplatedName parse(Source source);

TemplatedName auto_type(Position position)
	= new Flux::Parsing::TemplatedName( "auto", [], position );

TemplatedName void_type(Position position)
	= new Flux::Parsing::TemplatedName( "void", [], position );

TemplatedName function_type(Position position, TemplatedName returns, TemplatedName[] parameters) {
	TemplatedName[] _template = [returns];

	foreach i, v in parameters
		_template[i + 1] = v;

	return new Flux::Parsing::TemplatedName( "function", _template, position );
}

TemplatedName struct_type(Position position, string[] names, TemplatedName[] types) {
	TemplatedName[] _template = [];

	foreach i, v in names {
		_template[i] = new Flux::Parsing::TemplatedName( v, [types[i]], position );
	}

	return new Flux::Parsing::TemplatedName( "struct", _template, position );
}

TemplatedName list_type(Position position, TemplatedName value)
	= new Flux::Parsing::TemplatedName( "List", [value], position );

TemplatedName table_type(Position position, TemplatedName value, TemplatedName index)
	= new Flux::Parsing::TemplatedName( "Table", [index, value], position );

TemplatedName reference_type(Position position, TemplatedName value)
	= new Flux::Parsing::TemplatedName( "Reference", [value], position );

TemplatedName nullable_type(Position position, TemplatedName value)
	= new Flux::Parsing::TemplatedName( "Option", [value], position );

TemplatedName parse(Source source) {
	Lexer lexer = source.lexer;
	int start = lexer:mark();
	Position position = lexer:get().position;

	string name = Flux::Parsing::parseName( source ) || lexer:skipValue( Keyword, "auto" );
	TemplatedName type;

	if name {
		TemplatedName[] _template = [];

		if lexer:skip( Symbol, "<" ) {
			repeat
				classes[#classes + 1] = Flux::Parsing::types:parse( source );
			while lexer:skip( Symbol, "," );

			if !lexer:skip( Symbol, ">" )
				source:error "expected '>' after template";
		}

		type = new Flux::Parsing::TemplatedName( name, _template, position );
	}
	else if !source.file.context.isClassname && lexer:skip( Keyword, "function" ) {
		TemplatedName returns = Flux::Parsing::types:parse( source );
		TemplatedName[] parameters = [];

		if !lexer:skip( Symbol, "(" )
			source:error "expected '(' for function type parameters";

		if !lexer:skip( Symbol, ")" ) {
			repeat
				parameters[#parameters + 1] = Flux::Parsing::types:parse( source );
			while lexer:skip( Symbol, "," );

			if !lexer:skip( Symbol, ")" )
				source:error "expected ')' after function type parameters";
		}

		type = Flux::Parsing::types:function_type( position, returns, parameters );
	}
	else if !source.file.context.isClassname && lexer:skip( Keyword, "struct" ) {
		if !lexer:skip( Symbol, "{" )
			source:error "expected '{' for struct body";

		string[] names = [];
		TemplatedName[] classes = [];

		repeat {
			if #classes > 0 && lexer:test( Identifier ) && (lexer:test( Symbol, ",", 1 ) || lexer:test( Symbol, "}", 1 )) {
				classes[#classes + 1] = classes[#classes];
				names[#names + 1] = lexer:next().value;
			}
			else {
				classes[#classes + 1] = Flux::Parsing::types:parse( source );
				names[#names + 1] = lexer:skipValue( Identifier ) || source:error "expected struct member name";
			}
		}
		while lexer:skip( Symbol, "," );

		if !lexer:skip( Symbol, "}" )
			source:error "expected '}' after struct body";

		type = Flux::Parsing::types:struct_type( position, names, classes );
	}
	else
		source:error "expected typename";

	while true {
		let pos = lexer:get().position;

		if !source.file.context.isClassname && lexer:skip( Symbol, "[" ) {
			if !lexer:skip( Symbol, "]" ) source:error "expected ']' to close list type modifier";
			type = Flux::Parsing::types:list_type( pos, type );
		}
		else if !source.file.context.isClassname && lexer:skip( Symbol, "{" ) {
			if lexer:skip( Symbol, "}" )
				type = Flux::Parsing::types:table_type( pos, type, Flux::Parsing::types::void_type( pos ) );
			else {
				let index = Flux::Parsing::types:parse( source );
				if !lexer:skip( Symbol, "}" ) source:error "expected '}' to close array type modifier";

				type = Flux::Parsing::types:table_type( pos, type, index );
			}
		}
		else if lexer:skip( Symbol, "&" ) {
			type = Flux::Parsing::types:reference_type( pos, type );
		}
		else if !source.file.context.isClassname && lexer:skip( Symbol, "?" ) {
			type = Flux::Parsing::types:nullable_type( pos, type );
		}
		else break;
	}

	return type;
}
