
import TemplatedName;

namespace Flux::Parsing::types;

TemplatedName auto_type(Position position); // auto
TemplatedName void_type(Position position); // void
TemplatedName function_type(Position position, TemplatedName returns, TemplatedName[] parameters); // function
TemplatedName vararg_function_type(Position position, TemplatedName returns, TemplatedName[] parameters); // vararg_function
TemplatedName struct_type(Position position, string[] names, TemplatedName[] types); // struct
TemplatedName list_type(Position position, TemplatedName value); // List
TemplatedName table_type(Position position, TemplatedName value, TemplatedName index); // Table
TemplatedName reference_type(Position position, TemplatedName value); // Reference
TemplatedName nullable_type(Position position, TemplatedName value); // Option

TemplatedName parse(Source source);

TemplatedName auto_type(Position position)
	= new Flux::Parsing::TemplatedName( "auto", [], position );

TemplatedName void_type(Position position)
	= new Flux::Parsing::TemplatedName( "void", [], position );

TemplatedName function_type(Position position, TemplatedName returns, TemplatedName[] parameters) {
	TemplatedName[] _template = [returns];

	foreach i, v in parameters
		_template[i + 1] = v;

	return new Flux::Parsing::TemplatedName( "function", _template, position );
}

TemplatedName vararg_function_type(Position position, TemplatedName returns, TemplatedName[] parameters) {
	TemplatedName[] _template = [returns];

	foreach i, v in parameters
		_template[i + 1] = v;

	return new Flux::Parsing::TemplatedName( "vararg_function", _template, position );
}

TemplatedName struct_type(Position position, string[] names, TemplatedName[] types) {
	TemplatedName[] _template = [];

	foreach i, v in names {
		_template[i] = new Flux::Parsing::TemplatedName( v, [types[i]], position );
	}

	return new Flux::Parsing::TemplatedName( "struct", _template, position );
}

TemplatedName list_type(Position position, TemplatedName value)
	= new Flux::Parsing::TemplatedName( "List", [value], position );

TemplatedName table_type(Position position, TemplatedName value, TemplatedName index)
	= new Flux::Parsing::TemplatedName( "Table", [index, value], position );

TemplatedName reference_type(Position position, TemplatedName value)
	= new Flux::Parsing::TemplatedName( "Reference", [value], position );

TemplatedName nullable_type(Position position, TemplatedName value)
	= new Flux::Parsing::TemplatedName( "Option", [value], position );

TemplatedName parse(Source source) {
	Lexer lexer = source.lexer;
	Position position = lexer:get().position;

	string name = Flux::Parsing::parseName( source )
	           || lexer:skipValue( Keyword, "auto" );
	TemplatedName type;

	if name {
		TemplatedName[] _template = [];

		if lexer:skip( Symbol, "<" ) {
			repeat
				_template[#_template + 1] = Flux::Parsing::types::parse( source );
			while lexer:skip( Symbol, "," );

			if !lexer:skip( Symbol, ">" )
				source:error "expected '>' after template";
		}

		type = new Flux::Parsing::TemplatedName( name, _template, position );
	}
	else if !source.file.context:get_flag "is_parsing_classname" && lexer:skip( Keyword, "function" ) {
		TemplatedName returns = Flux::Parsing::types::parse( source );
		TemplatedName[] parameters = [];
		bool is_vararg = false;

		if !lexer:skip( Symbol, "(" )
			source:error "expected '(' for function type parameters";

		if !lexer:skip( Symbol, ")" ) {
			repeat {
				parameters[#parameters + 1] = Flux::Parsing::types::parse( source );

				if source.file.lexer:skip( Symbol, "..." ) {
					is_vararg = true;
					break;
				}
			}
			while lexer:skip( Symbol, "," );

			if !lexer:skip( Symbol, ")" )
				source:error "expected ')' after function type parameters";
		}

		if is_vararg
			type = Flux::Parsing::types::vararg_function_type( position, returns, parameters );
		else
			type = Flux::Parsing::types::function_type( position, returns, parameters );
	}
	else if !source.file.context:get_flag "is_parsing_classname" && lexer:skip( Keyword, "struct" ) {
		if !lexer:skip( Symbol, "{" )
			source:error "expected '{' for struct body";

		string[] names = [];
		TemplatedName[] classes = [];

		repeat {
			if #classes > 0 && lexer:test( Identifier ) && (lexer:test( Symbol, ",", 1 ) || lexer:test( Symbol, "}", 1 )) {
				classes[#classes + 1] = classes[#classes];
				names[#names + 1] = lexer:next().value;
			}
			else {
				classes[#classes + 1] = Flux::Parsing::types::parse( source );
				names[#names + 1] = lexer:skipValue( Identifier ) || source:error "expected struct member name";
			}
		}
		while lexer:skip( Symbol, "," );

		if !lexer:skip( Symbol, "}" )
			source:error "expected '}' after struct body";

		type = Flux::Parsing::types::struct_type( position, names, classes );
	}
	else
		source:error "expected typename";

	while true {
		let pos = lexer:get().position;

		if  !source.file.context:get_flag "is_parsing_classname"
		&& (!source.file.context:get_flag "is_parsing_new_type" || !source.file.lexer:test( Integer, null, 1 ))
		&& lexer:skip( Symbol, "[" ) {
			if !lexer:skip( Symbol, "]" ) source:error "expected ']' to close list type modifier";
			type = Flux::Parsing::types::list_type( pos, type );
		}
		else if !source.file.context:get_flag "is_parsing_classname"
		&& lexer:skip( Symbol, "{" ) {
			if lexer:skip( Symbol, "}" )
				type = Flux::Parsing::types::table_type( pos, type, Flux::Parsing::types::void_type( pos ) );
			else {
				let index = Flux::Parsing::types::parse( source );
				if !lexer:skip( Symbol, "}" ) source:error "expected '}' to close array type modifier";

				type = Flux::Parsing::types::table_type( pos, type, index );
			}
		}
		else if !source.file.context:get_flag "is_parsing_classname"
		&& lexer:skip( Symbol, "&" ) {
			type = Flux::Parsing::types::reference_type( pos, type );
		}
		else if !source.file.context:get_flag "is_parsing_classname" && lexer:skip( Symbol, "?" ) {
			type = Flux::Parsing::types::nullable_type( pos, type );
		}
		else break;
	}

	return type;
}
