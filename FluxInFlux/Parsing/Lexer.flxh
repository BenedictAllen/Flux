
import TokenType;
import Position;
import Token;

namespace Flux::Parsing;

string getline( string text, int line );

let escaped_characters = setmetatable( {
	["n"] = "\n", ["0"] = "\0", ["r"] = "\r", ["t"] = "\t";
}, { __index = lambda a b => b } );

class Lexer {
	int position = 1;
	string text = "";

	string source = "string";
	int character = 1, line = 1;
	string strline = "";

	Token[] buffer = [];
	int buffer_position = 1;

	Lexer(string text, null string source = "string") {
		self.source = source;
		self.text = text;
		self.buffer = [];
	}

	Position getPosition(null int n = 0);
	bool isEOF();

	void error(string err, null Position position = self:getPosition());

	Token consumePattern(TokenType type, string pattern);

	Token consumeInstruction();
	Token consumeString(); // String, Character
	Token consumeBacktick(); // Backtick
	Token consumeWord(); // Identifier, Keyword, Boolean, Null
	Token consumeNumber(); // Float, Integer, Byte
	Token consumeHexadecimal(); // Hexadecimal
	Token consumeBinary(); // Binary
	Token consumeSymbol(); // Symbol

	void skipWhitespace();
	void skipComment();
	void skipNewline();

	void consume();

	int mark();
	void jump(int position);

	Token get();
	Token peek(null int lookahead = 1);
	Token next();
	Token back();

	Token test(TokenType type, null string value, null int lookahead);
	Token skip(TokenType type, null string value);

	string testValue(TokenType type, null string value, null int lookahead);
	string skipValue(TokenType type, null string value);
}
