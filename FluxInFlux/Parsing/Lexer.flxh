
import TokenType;
import Position;
import Token;

namespace Flux::Parsing;

string getline( string text, int line );

let escaped_characters = setmetatable( {
	["n"] = "\n", ["0"] = "\0", ["r"] = "\r", ["t"] = "\t";
}, { __index = lambda a b => b } );

class Lexer {
	int position = 1;
	string text = "";

	string source_name_name = "string";
	int character = 1, line = 1;
	string strline = "";

	Source source;

	Token[] buffer = [];
	int buffer_position = 1;

	Lexer(string text, string source_name, Source source) {
		self.source_name = source_name;
		self.text = text;
		self.source = source;
		self.buffer = [];
	}

	Position getPosition(null int n = 0);
	bool isEOF();

	void error(string err, null Position position = self:getPosition());

	Token consumePattern(TokenType type, string pattern);

	void consumeInstruction();
	void consumeString(); // String, Character
	void consumeBacktick(); // Backtick
	void consumeWord(); // Identifier, Keyword, Boolean, Null
	void consumeNumber(); // Float, Integer, Byte
	void consumeHexadecimal(); // Hexadecimal
	void consumeBinary(); // Binary
	void consumeSymbol(); // Symbol

	void skipWhitespace();
	void skipComment();
	void skipNewline();

	void consume();

	int mark();
	void jump(int position);

	Token get();
	Token peek(null int lookahead = 1);
	Token next();
	Token back();

	Token test(TokenType type, null string value, null int lookahead);
	Token skip(TokenType type, null string value);

	string testValue(TokenType type, null string value, null int lookahead);
	string skipValue(TokenType type, null string value);
}
