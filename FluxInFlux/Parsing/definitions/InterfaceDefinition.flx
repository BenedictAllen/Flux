
namespace Flux::Parsing;

bool InterfaceDefinition:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if !source.context.isNamespace || !lexer:skip( Keyword, "interface" ) return false;
	
	string name = Flux::Parsing::resolveDefinitionName( source, Flux::Parsing::parseName( source ) || source:error "expected name after 'interface'" );
	string[] _implements = [];
	
	if lexer:skip( Keyword, "implements" )
		repeat {
			_implements[#_implements + 1] = Flux::Parsing::parseName( source ) || source:error "expected interface name";
		}
		while lexer:skip( Symbol, "," );

	if !lexer:skip( Symbol, "{" )
		source:error "expected '{' for interface body";

	source:pushInterfaceContext();
	source:pushBlock();

	while !lexer:skip( Symbol, "}" ) {
		if lexer:isEOF() source:error "expected '}' to close interface body";

		Flux::Parsing::Definition:parse( source );
	}

	source:popContext();

	let definitions = source:popBlock();
	let selftype = new Flux::Parsing::Typename( name, position );
	let selfref = new Flux::Parsing::ReferenceExpression( name, position );

	ClassMember[] members = [];

	foreach definition in definitions {
		members[#members + 1] = new Flux::Parsing::ClassMember( definition );
	}

	source:push( new Flux::Parsing::InterfaceDefinition( name, members, _implements, position ) );

	foreach definition in definitions {
		if definition.value && definition._type.type == Flux::Parsing::ASTNodeType.FunctionType
			source:push( new Flux::Parsing::Definition(
				definition._type, selftype, definition.name, definition.value, definition.isConst, definition.position ) );
		else if definition.value
			source:push( new Flux::Parsing::BinaryExpression( 
				new Flux::Parsing::DotIndex( selfref, definition.name ),
				new Flux::Parsing::Cast( definition.value, definition._type ),
				"=", position ) );
	}

	return true;
}

string InterfaceDefinition:serialize()
	= "interface " `concat` self.name
		`concat` (#self._implements > 0 && " implements " `concat` table.concat(self._implements, ", ") || "")
		`concat` " {\n\t" `concat` (self.members `concattenate` "\n\t") `concat` "\n}";
