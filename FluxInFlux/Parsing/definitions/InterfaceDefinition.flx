
namespace Flux::Parsing;

bool InterfaceDefinition:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if !source.context.isNamespace || !lexer:skip( Keyword, "interface" ) return false;
	
	string name = Flux::Parsing::resolveDefinitionName( source, Flux::Parsing::parseName( source ) || source:error "expected name after 'interface'" );
	string[] _implements = [];
	
	if lexer:skip( Keyword, "implements" )
		repeat {
			_implements[#_implements + 1] = Flux::Parsing::parseName( source ) || source:error "expected interface name";
		}
		while lexer:skip( Symbol, "," );

	if !lexer:skip( Symbol, "{" )
		source:error "expected '{' for interface body";

	source:pushInterfaceContext();
	source:pushBlock();

	while !lexer:skip( Symbol, "}" ) {
		if lexer:isEOF() source:error "expected '}' to close interface body";

		if (lexer:test( Keyword, "public" ) || lexer:test( Keyword, "private" )) && lexer:test( Symbol, ":", 1 ) {
			source.context:setPublic( lexer:skip( Keyword, "public" ) && true || lexer:skip( Keyword, "private" ) && false );
			lexer:next();
		}
		else
			Flux::Parsing::Definition:parse( source ) || source:error "expected definition";
	}

	source:popContext();

	let definitions = source:popBlock();
	let selftype = new Flux::Parsing::Typename( name, position );
	let selfref = new Flux::Parsing::ReferenceExpression( name, position );

	ClassMember[] members = [];

	foreach definition in definitions {
		members[#members + 1] = new Flux::Parsing::ClassMember( definition );
	}

	source:push( new Flux::Parsing::InterfaceDefinition( name, members, _implements, position ) );

	foreach definition in definitions {
		if definition.type == Flux::Parsing::ASTNodeType.TemplateDefinition {
			if definition.value
				source:push( new Flux::Parsing::TemplateDefinition(
					definition._type, selftype, definition.name, definition.value, false, false, false, definition._template, definition.position ) );
		}
		else
			if definition.value
				source:push( new Flux::Parsing::Definition(
					definition._type, selftype, definition.name, definition.value, false, false, false, definition.position ) );
	}

	return true;
}

string InterfaceDefinition:serialize()
	= "interface " `concat` self.name
		`concat` (#self._implements > 0 && " implements " `concat` table.concat(self._implements, ", ") || "")
		`concat` " {\n\t" `concat` (self.members `concattenate` "\n\t") `concat` "\n}";
