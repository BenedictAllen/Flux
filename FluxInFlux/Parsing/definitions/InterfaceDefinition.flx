
namespace Flux::Parsing;

bool InterfaceDefinition:parse(Source source) {
	let lexer = source.lexer;

	TemplateList _template;
	Position template_position = lexer:get().position;

	// read a template
	if lexer:skip( Keyword, "template" ) {
		if !lexer:skip( Symbol, "<" ) source:error "expected '<' after 'template'";
		_template = Flux::Parsing::TemplateList:parse( source );
		if !lexer:skip( Symbol, ">" ) source:error "expected '>' after template list";
	}

	Position position = lexer:get().position;

	if !lexer:skip( Keyword, "interface" )
		if _template
			source:error( "expected definition after template" );
		else return false;

	if !_template
		_template = new Flux::Parsing::TemplateList([], []);

	// probably remove this? why limit classes to the main body of a file?
	if !source.context.isNamespace
		source:error "invalid section to define interface";

	source:pushClassnameContext();
	
	Type name = Flux::Parsing::Type:parse( source );
	string[] _implements = [];

	source:popContext();

	name.name = Flux::Parsing::resolveDefinitionName( source, name.name );
	
	if lexer:skip( Keyword, "implements" )
		repeat {
			_implements[#_implements + 1] = Flux::Parsing::parseName( source ) || source:error "expected interface name";
		}
		while lexer:skip( Symbol, "," );

	if !lexer:skip( Symbol, "{" )
		source:error "expected '{' for interface body";

	source:pushClassContext(name);
	source:pushBlock();

	while !lexer:skip( Symbol, "}" ) {
		if lexer:isEOF() source:error "expected '}' to close interface body";

		if (lexer:test( Keyword, "public" ) || lexer:test( Keyword, "private" )) && lexer:test( Symbol, ":", 1 ) {
			source.context:setPublic( lexer:skip( Keyword, "public" ) && true || lexer:skip( Keyword, "private" ) && false );
			lexer:next();
		}
		else
			Flux::Parsing::Definition:parse( source ) || source:error "expected definition in interface body";
	}

	source:popContext();

	let definitions = source:popBlock();

	ClassMember[] members = [];

	source:push( new Flux::Parsing::InterfaceDefinition( name, _implements, _template, members, position ) );

	foreach definition in definitions {
		Definition raw_def;

		// if the definition is a normal definition, it needs a template added to it
		if definition typeof Flux::Parsing::Definition && #_template.names > 0 {
			definition = new Flux::Parsing::TemplateDefinition(definition, _template, template_position);
			raw_def = definition.definition;
		}
		// if the definition is a templated definition, add the class template params to it
		else if #_template.names > 0 {
			for (int i = #_template.names, i > 0, i--) {
				table.insert( definition.template_list.names, 1, _template.names[i] );
				table.insert( definition.template_list.classes, 1, _template.classes[i] );
			}
			raw_def = definition.definition;
		}
		// if the class has no template
		else
			raw_def = definition;

		members[#members + 1] = new Flux::Parsing::ClassMember( definition );

		raw_def._class = name;

		if raw_def.value
			source:push( definition );
	}

	return true;
}

string InterfaceDefinition:serialize()
	= "template <" `concat` self._template:serialize() `concat` ">\n"
		`concat` "interface " `concat` self.name:serialize()
		`concat` (self.container && " (" `concat` self.container[1]:serialize() `concat` ", " `concat` self.container[2]:serialize() `concat` ")" || "")
		`concat` (self._extends && " extends " `concat` self._extends:serialize() || "")
		`concat` (#self._implements > 0 && " implements " `concat` table.concat(self._implements, ", ") || "")
		`concat` " {\n\t" `concat` (self.members `concattenate` "\n\t") `concat` "\n}";
