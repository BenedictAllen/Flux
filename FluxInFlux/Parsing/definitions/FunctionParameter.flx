
import TemplatedName;
import types;

namespace Flux::Parsing;

class FunctionParameter {
	TemplatedName type;
	string name;

	FunctionParameter(TemplatedName type, string name, null Position position = type.position) {
		self.type = type;
		self.name = name;
		self.position = position;
	}

	FunctionParameter parse(Source source, bool parameterNamesGiven, null FunctionParameter prev);

	string serialize();
}

FunctionParameter FunctionParameter:parse(Source source, bool parameterNamesGiven, null FunctionParameter prev) {
	Lexer lexer = source.lexer;
	TemplatedName type;

	try {
		type = Flux::Parsing::types::parse(source);
	}
	catch ParserException e {
		if parameterNamesGiven && !e:find "expected typename"
			throw new ParserException( e );
	}

	string name = parameterNamesGiven && lexer:skipValue( Identifier );

	if !name && lexer:test( Symbol, "..." ) {
		if !type && !prev
			source:error( "expected type before '...'" );

		name = lexer:next().value;
	}

	if name == null || type == null {
		if type != null && prev != null && #type._template == 0 { // when the parameter type is the same as previous
			name = type.name;
			type = prev.type;
		}
		else if type == null && name != null && prev != null { // when the parameter type is the same as previous, no idea how this can happen tbh, but I wrote it ages ago and am scared to remove it
			type = prev.type;
		}
		else if prev && !parameterNamesGiven { // if there was no parameter name or type, but it doesn't matter
			type = type || prev.type;
		}
		else if type != null {
			source:error "expected name after type";
		}
		else {
			source:error "expected typename";
		}
	}

	return new Flux::Parsing::FunctionParameter( type, name || "" );
}

string FunctionParameter:serialize()
	= self.type:serialize() `concat` " " `concat` self.name;
