
import TemplatedName;
import Declaration;
import EnumDefinition;
import imports.Source;
import types;
import expressions.AutoCast;

namespace Flux::Parsing;

// private class TypedName = struct { TemplatedName type, name, Position position };
// private class DefinitionFlags = struct { bool is_public, is_public_set, is_const, is_static, Position static_pos, const_pos, public_pos }

// determines whether a definition follows
bool is_definition(Source source);

// parses an unknown definition
void parse(Source source);

// parses a class or interface definition
void parse_class(Source source, bool is_interface, TemplateList _template, DefinitionFlags modifiers);

// parses an enum definition
void parse_enum(Source source, DefinitionFlags modifiers);

// parses a generic definition
void parse_definition(Source source);

// parses a method definition i.e. int x:f() or float y<T>:g()
void parse_method_definition(Source source, DefinitionFlags modifiers, TypedName name);
void parse_function_definition(Source source, DefinitionFlags modifiers, TypedName name);
void parse_var_definition(Source source, DefinitionFlags modifiers, TypedName name);

// parses a template list before a definition
TemplateList parse_template_begin(Source source);

// parses the modifier keywords
DefinitionFlags parse_modifiers(Source source); // public, private, static, const

// parses the beginning type of a generic definition
TypedName parse_initial_type_and_name(Source source);

bool is_definition(Source source) {
	Lexer lexer = source.file.lexer;

	if lexer:test( Keyword ) {
		string word = lexer:get().value;

		if word == "public"
		|| word == "private"
		|| word == "static"
		|| word == "abstract"
		|| word == "final"
		|| word == "class"
		|| word == "interface"
		|| word == "enum"
		|| word == "template"
		|| word == "const"
			return true;
	}

	let mark = lexer:mark();

	if source.file.context:get_flag "is_parsing_body"
	&& lexer:skip( Identifier, source.file.context.class_name )
	&& lexer:test( Symbol, "(" ) {
		lexer:jump( mark );
		return true;
	}
	else {
		lexer:jump( mark );

		string name = lexer:skipValue( Identifier );

		if name
		&& lexer:skip( Symbol, ":" )
		&& lexer:skip( Identifier, name )
		&& lexer:skip( Symbol, "(" ) {
			lexer:jump( mark );
			return true;
		}
		else
			lexer:jump( mark );
	}

	try {
		Flux::Parsing::types::parse( source );

		if !source.file.lexer:test( Identifier ) && !source.file.lexer:test( Keyword, "setter" ) && !source.file.lexer:test( Keyword, "getter" ) && !source.file.lexer:test( Keyword, "operator" )
			throw new not_important "nope";
	}
	catch just to_fix_syntax {}
	default { // catch any error and return false
		lexer:jump( mark ); return false;
	}

	lexer:jump( mark ); return true;
}

void parse(Source source) {
	TemplateList _template = Flux::Parsing::parse_template_begin( source );
	DefinitionFlags modifiers = Flux::Parsing::parse_modifiers( source );
	Position position = source.lexer:get().position;

	if modifiers.is_public_set && !modifiers.is_static && !modifiers.is_const && source.file.lexer:skip( Symbol, ":" ) {
		if !source.file.context:get_flag "is_root_level"
			source:error( "cannot set global public state at function-level", modifiers.public_pos );

		source.file.context.is_global_public = modifiers.is_public;
	}
	else if source.lexer:skip( Keyword, "class" ) {
		return Flux::Parsing::parse_class( source, false, _template, modifiers, position );
	}
	else if source.lexer:skip( Keyword, "interface" ) {
		return Flux::Parsing::parse_class( source, true, _template, modifiers, position );
	}
	else if source.lexer:skip( Keyword, "enum" ) {
		return Flux::Parsing::parse_enum( source, modifiers, position );
	}
	else {
		return Flux::Parsing::parse_definition( source, _template, modifiers );
	}
}

void parse_class(Source source, bool is_interface, TemplateList _template, DefinitionFlags modifiers, Position position) {

}

void parse_enum(Source source, DefinitionFlags modifiers, Position position) {
	if !source.file.context:get_flag "is_root_level"
		source:error( "invalid location to define enum", position );

	if modifiers.is_static
		source:error( "unexpected 'static' before enum definition", modifiers.static_pos );

	if modifiers.is_const
		source:error( "unexpected 'const' before enum definition: enums are implicitly constant", modifiers.const_pos );

	string[] members = [];
	string name = Flux::Parsing::parseName( source )
	           || source:error "expected enum name after 'enum'";

	if !source.file.lexer:skip( Symbol, "{" )
		source:error "expected '{' after enum name";

	repeat {
		members[#members + 1] = source.file.lexer:skipValue( Identifier )
		                     || source:error "expected identifier for enum member";
	}
	while (source.file.lexer:skip( Symbol, "," )
	   || (source.file.lexer:skip( Symbol, ";" ) && !source.file.lexer:test( Symbol, "}" )));

	if !source.file.lexer:skip( Symbol, "}" )
		source:error "expected '}' to close enum body";

	source.file.lexer:skip( Symbol, ";" );
	source.file:push( new Flux::Parsing::EnumDefinition( Flux::Parsing::resolveDefinitionName( source, name ), members, modifiers.is_public, position ) );

	foreach member in members {
		new Flux::Parsing::TemplatedName enum_name( name, [], position );
		new Flux::Parsing::ReferenceExpression enum_lookup( name, position );
		new Flux::Parsing::DotIndex enum_member_lookup( enum_lookup, member, position );

		source.file:push( new Flux::Parsing::Declaration( enum_name, member, position, true, modifiers.is_public, false, null, enum_member_lookup ) );
	}
}

void parse_definition(Source source, TemplateList _template, DefinitionFlags modifiers) {
	if modifiers.is_public_set && !source.file.context:get_flag "is_root_level"
		source:error( "cannot declare function-level definition as " `concat` (modifiers.is_public && "public" || "private"), modifiers.public_pos );

	TypedName type_name = Flux::Parsing::parse_initial_type_and_name( source );

	if source.lexer:skip( Symbol, "<" ) {
		if type_name.name.name:find "[^%w_]"
			source:error( "invalid template class '" `concat` type_name.name.name `concat` "'", source.file.lexer:peek( -1 ).position );

		TemplatedName[] _template = [];

		repeat {
			_template[#_template + 1] = Flux::Parsing::TemplatedName:parse( source );
		}
		while source.file.lexer:skip( Symbol, "," );

		type_name.name = new Flux::Parsing::TemplatedName( type_name.name.name, _template, type_name.name.position );

		if !source.file.lexer:skip( Symbol, ">" )
			source:error( "expected '>' to end template list" );

		if !source.file.lexer:skip( Symbol, ":" )
			source:error( "expected ':' for method definition" );

		return Flux::Parsing::parse_method_definition( source, _template, modifiers, type_name );
	}
	else if source.lexer:skip( Symbol, ":" ) {
		if type_name.name.name:find "[^%w_]"
			source:error( "invalid class for method definition '" `concat` type_name.name.name `concat` "'", source.file.lexer:peek( -1 ).position );

		return Flux::Parsing::parse_method_definition( source, _template, modifiers, type_name );
	}
	else if source.lexer:skip( Symbol, "(" ) {
		return Flux::Parsing::parse_function_definition( source, _template, modifiers, type_name );
	}
	else {
		if type_name.name.name:find "[^%w_]"
			source:error( "invalid name for definition '" `concat` type_name.name.name `concat` "'", type_name.name.position );

		return Flux::Parsing::parse_var_definition( source, modifiers, type_name );
	}
}

void parse_method_definition(Source source, TemplateList _template, DefinitionFlags modifiers, TypedName name) {

}

void parse_function_definition(Source source, TemplateList _template, DefinitionFlags modifiers, TypedName name) {

}

void parse_var_definition(Source source, DefinitionFlags modifiers, TypedName name) {
	Lexer lexer = source.lexer;
	bool is_const = modifiers.is_const;
	bool is_public = modifiers.is_public;
	bool is_static = modifiers.is_static;

	if lexer:skip( Symbol, "=" ) {
		let expr = Flux::Parsing::Expression:parse( source );

		Flux::Parsing::expectSemicolon( source, "end of definition" );

		expr = new Flux::Parsing::AutoCast( expr, name.type );

		source.file:push( new Flux::Parsing::Declaration(
			name.type, Flux::Parsing::resolveDefinitionName( source, name.name.name ),
			name.position, is_const, is_public, is_static, null, expr
		));
	}
	else {
		Flux::Parsing::expectSemicolon( source, "end of declaration" );

		source.file:push( new Flux::Parsing::Declaration(
			name.type, Flux::Parsing::resolveDefinitionName( source, name.name.name ),
			name.position, is_const, is_public, is_static, null, null
		));
	}
}

TemplateList parse_template_begin(Source source)
	if source.lexer:skip( Keyword, "template" ) {
		if !source.lexer:skip( Symbol, "<" )
			source:error "expected '<' after 'template'";

		TemplateList _template = Flux::Parsing::TemplateList:parse( source );

		if !source.lexer:skip( Symbol, ">" )
			source:error "expected '>' after template list";

		return _template;
	}
	else return null;

DefinitionFlags parse_modifiers(Source source) {
	DefinitionFlags modifiers = {
		is_public = false;
		is_public_set = false;
		is_static = false;
		is_const = false;
		public_pos = source.file.lexer:get().position;
		static_pos = source.file.lexer:get().position;
		const_pos = source.file.lexer:get().position;
	};
	Lexer lexer = source.lexer;

	if lexer:skip( Keyword, "public" ) {
		modifiers.is_public_set = true;
		modifiers.is_public = true;
		modifiers.static_pos = source.file.lexer:get().position;
		modifiers.const_pos = source.file.lexer:get().position;
	}
	else if lexer:skip( Keyword, "private" ) {
		modifiers.is_public_set = true;
		modifiers.is_public = false;
		modifiers.static_pos = source.file.lexer:get().position;
		modifiers.const_pos = source.file.lexer:get().position;
	}
	else {
		modifiers.is_public_set = false;
		modifiers.is_public = source.file.context.is_global_public;
	}

	if lexer:skip( Keyword, "static" ) {
		modifiers.is_static = true;
		modifiers.const_pos = source.file.lexer:get().position;
	}

	if lexer:skip( Keyword, "const" )
		modifiers.is_const = true;

	return modifiers;
}

TypedName parse_initial_type_and_name(Source source) {
	// A:A() -> void A leaving colon
	// ClassName() -> void ClassName
	// int x -> int x

	Lexer lexer = source.lexer;
	Position position = lexer:get().position;

	if source.file.context:get_flag "is_parsing_body" && lexer:skip( Identifier, source.file.context.class_name ) {
		return {
			type = new Flux::Parsing::TemplatedName( "void", null, position );
			name = source.file.context.class_name;
			position = position;
		};
	}
	else {
		string name = lexer:skipValue "Identifier";

		if name {
			if lexer:skip( Symbol, ":" ) {
			 	if lexer:skip( Identifier, name ) {
					return {
						type = new Flux::Parsing::TemplatedName( "void", null, position );
						name = name;
						position = position;
					};
				}

				lexer:back();
			}

			lexer:back();
		}

		TemplatedName type = Flux::Parsing::types::parse( source );
		Position pos = source.file.lexer:get().position;
		new Flux::Parsing::TemplatedName name( Flux::Parsing::parseMethodName( source ) || throw new WTF "oh no this is bad", [], pos );

		return {
			type = type;
			name = name;
			position = position;
		};
	}
}
