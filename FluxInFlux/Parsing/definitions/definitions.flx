
import TemplatedName;
import Declaration;
import EnumDefinition;
import imports.Source;
import types;

namespace Flux::Parsing;

// private class TypedName = struct { TemplatedName type, string name, Position position };

// determines whether a definition follows
bool is_definition(Source source);

// parses an unknown definition
void parse(Source source);

// parses a class or interface definition
void parse_class(Source source, bool is_interface, TemplateList _template, bool{string} modifiers);

// parses an enum definition
void parse_enum(Source source, bool{string} modifiers);

// parses a generic definition
void parse_definition(Source source);

// parses a method definition i.e. int x:f() or float y<T>:g()
void parse_method_definition(Source source, bool{string} modifiers, TypedName name);
void parse_function_definition(Source source, bool{string} modifiers, TypedName name);
void parse_var_definition(Source source, bool{string} modifiers, TypedName name);

// parses a template list before a definition
TemplateList parse_template_begin(Source source);

// parses the modifier keywords
bool{string} parse_modifiers(Source source); // public, private, static, abstract, final, const

// parses the beginning type of a generic definition
TypedName parse_initial_type_and_name(Source source);

bool is_definition(Source source) {
	Lexer lexer = source.file.lexer;

	if lexer:test( Keyword ) {
		string word = lexer:get().value;

		if word == "public"
		|| word == "private"
		|| word == "static"
		|| word == "abstract"
		|| word == "final"
		|| word == "class"
		|| word == "interface"
		|| word == "enum"
		|| word == "template"
			return true;
	}

	let mark = lexer:mark();

	if source.file.context:get_flag "is_parsing_body"
	&& lexer:skip( Identifier, source.file.context.class_name )
	&& lexer:test( Symbol, "(" ) {
		lexer:jump( mark );
		return true;
	}
	else {
		lexer:jump( mark );

		string name = lexer:skipValue( Identifier );

		if name
		&& lexer:skip( Symbol, ":" )
		&& lexer:skip( Identifier, name )
		&& lexer:skip( Symbol, "(" ) {
			lexer:jump( mark );
			return true;
		}
		else
			lexer:jump( mark );
	}

	try {
		Flux::Parsing::types::parse( source );

		if !source.file.lexer:test( Identifier )
			throw new not_important "nope";
	}
	catch just to_fix_syntax {}
	default { // catch any error and return false
		lexer:jump( mark ); return false;
	}

	lexer:jump( mark ); return true;
}

void parse(Source source) {
	TemplateList _template = Flux::Parsing::parse_template_begin( source );
	bool{string} modifiers = Flux::Parsing::parse_modifiers( source );
	Position position = source.lexer:get().position;

	if source.lexer:skip( Keyword, "class" )
		return Flux::Parsing::parse_class( source, false, _template, modifiers, position );
	else if source.lexer:skip( Keyword, "interface" )
		return Flux::Parsing::parse_class( source, true, _template, modifiers, position );
	else if source.lexer:skip( Keyword, "enum" )
		return Flux::Parsing::parse_enum( source, _template, modifiers, position );
	else
		return Flux::Parsing::parse_definition( source, _template, modifiers );
}

void parse_class(Source source, bool is_interface, TemplateList _template, bool{string} modifiers, Position position) {

}

void parse_enum(Source source, bool{string} modifiers, Position position) {
	string name = Flux::Parsing::parseName( source )
	           || source:error "expected enum name after 'enum'";
	string[] members = [];

	if !source.file.lexer:skip( Symbol, "{" )
		source:error "expected '{' after enum name";

	repeat {
		members[#members + 1] = source.file.lexer:skipValue( Identifier )
		                     || source:error "expected identifier for enum member";
	}
	while (source.file.lexer:skip( Symbol, "," )
	   || (source.file.lexer:skip( Symbol, ";" ) && !source.file.lexer:test( Symbol, "}" )));

	if !source.file.lexer:skip( Symbol, "}" )
		source:error "expected '}' to close enum body";

	source.file.lexer:skip( Symbol, ";" );
	source.file:push( new Flux::Parsing::EnumDefinition( Flux::Parsing::resolveDefinitionName( source, name ), members, position ) );

	print "Got to here! :)";
}

void parse_definition(Source source, TemplateList _template, bool{string} modifiers) {
	TypedName type_name = Flux::Parsing::parse_initial_type_and_name( source );

	if source.lexer:skip( Symbol, ":" )
		return Flux::Parsing::parse_method_definition( source, _template, modifiers, type_name );
	else if source.lexer:skip( Symbol, "(" )
		return Flux::Parsing::parse_function_definition( source, _template, modifiers, type_name );
	else
		return Flux::Parsing::parse_var_definition( source, modifiers, type_name );
}

void parse_method_definition(Source source, TemplateList _template, bool{string} modifiers, TypedName name) {

}

void parse_function_definition(Source source, TemplateList _template, bool{string} modifiers, TypedName name) {

}

void parse_var_definition(Source source, bool{string} modifiers, TypedName name) {
	Lexer lexer = source.lexer;
	bool is_const = modifiers["const"];
	bool is_public = modifiers["public"];
	bool is_static = modifiers["static"];

	if !modifiers["public_is_set"]
		is_public /*= calculated_default_public*/ = true;

	if lexer:skip( Symbol, "=" ) {
		let expr = Flux::Parsing::Expression:parse( source );

		Flux::Parsing::expectSemicolon( source, "end of definition" );

		source.file:push( new Flux::Parsing::Declaration(
			name.type, Flux::Parsing::resolveDefinitionName( source, name.name ),
			name.position, is_const, is_public, is_static, null, expr
		));
	}
	else {
		Flux::Parsing::expectSemicolon( source, "end of declaration" );

		source.file:push( new Flux::Parsing::Declaration(
			name.type, Flux::Parsing::resolveDefinitionName( source, name.name ),
			name.position, is_const, is_public, is_static, null, null
		));
	}
}

TemplateList parse_template_begin(Source source)
	if source.lexer:skip( Keyword, "template" ) {
		if !source.lexer:skip( Symbol, "<" )
			source:error "expected '<' after 'template'";

		TemplateList _template = Flux::Parsing::TemplateList:parse( source );

		if !source.lexer:skip( Symbol, ">" )
			source:error "expected '>' after template list";

		return _template;
	}
	else return null;

bool{string} parse_modifiers(Source source) {
	bool{string} modifiers = {};
	Lexer lexer = source.lexer;

	if lexer:skip( Keyword, "public" ) {
		modifiers["public_is_set"] = true;
		modifiers["public"] = true;
	}
	else if lexer:skip( Keyword, "private" ) {
		modifiers["public_is_set"] = true;
		modifiers["public"] = false;
	}
	else {
		modifiers["public_is_set"] = false;
		modifiers["public"] = false;
	}

	if lexer:skip( Keyword, "static" )
		modifiers["static"] = true;

	if lexer:skip( Keyword, "const" )
		modifiers["const"] = true;

	if lexer:skip( Keyword, "final" )
		modifiers["final"] = true;

	if lexer:skip( Keyword, "abstract" )
		modifiers["abstract"] = true;

	return modifiers;
}

TypedName parse_initial_type_and_name(Source source) {
	// A:A() -> void A leaving colon
	// ClassName() -> void ClassName
	// int x -> int x

	Lexer lexer = source.lexer;
	Position position = lexer:get().position;

	if source.file.context:get_flag "is_parsing_body" && lexer:skip( Identifier, source.file.context.class_name ) {
		return {
			type = new Flux::Parsing::TemplatedName( "void", null, position );
			name = source.file.context.class_name;
			position = position;
		};
	}
	else {
		string name = lexer:skipValue "Identifier";

		if lexer:skip( Symbol, ":" ) {
		 	if lexer:skip( Identifier, name ) {
				return {
					type = new Flux::Parsing::TemplatedName( "void", null, position );
					name = name;
					position = position;
				};
			}

			lexer:back();
		}

		lexer:back();

		TemplatedName type = Flux::Parsing::types::parse( source );
		string name = lexer:skipValue( Identifier ) || throw new WTF "oh no this is bad";

		return {
			type = type;
			name = name;
			position = position;
		};
	}
}
