
import TemplatedName;
import Declaration;
import EnumDefinition;
import MethodDefinition;
import imports.Source;
import types;
import expressions.AutoCast;
import parsing_utils;

namespace Flux::Parsing;

// private class TypedName = struct { TemplatedName type, name, Position position };
// private class DefinitionFlags = struct { bool is_public, is_public_set, is_const, is_static, Position static_pos, const_pos, public_pos }

// determines whether a definition follows
bool is_definition(Source source);

// parses an unknown definition
void parse(Source source);

// parses a class or interface definition
void parse_class(Source source, bool is_interface, TemplateList _template, DefinitionFlags modifiers);

// parses an enum definition
void parse_enum(Source source, DefinitionFlags modifiers);

// parses a generic definition
void parse_definition(Source source);

// parses a method definition i.e. int x:f() or float y<T>:g()
void parse_method_definition(Source source, DefinitionFlags modifiers, TypedName name);
void parse_function_definition(Source source, DefinitionFlags modifiers, TypedName name);
void parse_var_definition(Source source, DefinitionFlags modifiers, TypedName name);

// parses a template list before a definition
TemplateList parse_template_begin(Source source);

// parses the modifier keywords
DefinitionFlags parse_modifiers(Source source); // public, private, static, const

// parses the beginning type of a generic definition
TypedName parse_initial_type_and_name(Source source);

bool is_definition(Source source) {
	Lexer lexer = source.file.lexer;

	if lexer:test( Keyword ) {
		string word = lexer:get().value;

		if word == "public"
		|| word == "private"
		|| word == "static"
		|| word == "abstract"
		|| word == "final"
		|| word == "class"
		|| word == "interface"
		|| word == "enum"
		|| word == "template"
		|| word == "const"
		|| word == "void"
			return true;
	}

	let mark = lexer:mark();

	if source.file.context:get_flag "is_parsing_body" // constructor inside class body
	&& lexer:skip( Identifier, source.file.context.class_name )
	&& lexer:test( Symbol, "(" ) {
		lexer:jump( mark );
		return true;
	}
	else { // constructor outside class body
		// note this won't work for C<T>:C() :/
		lexer:jump( mark );

		string name = lexer:skipValue( Identifier );

		if name
		&& lexer:skip( Symbol, ":" )
		&& lexer:skip( Identifier, name )
		&& lexer:skip( Symbol, "(" ) {
			lexer:jump( mark );
			return true;
		}
		else
			lexer:jump( mark );
	}

	try {
		Flux::Parsing::types::parse( source );

		if !source.file.lexer:test( Identifier ) && !source.file.lexer:test( Keyword, "setter" ) && !source.file.lexer:test( Keyword, "getter" ) && !source.file.lexer:test( Keyword, "operator" )
			throw new not_important "nope";
	}
	catch just to_fix_syntax {}
	default { // catch any error and return false
		lexer:jump( mark ); return false;
	}//*/

	lexer:jump( mark ); return true;
}

void parse(Source source) {
	TemplateList _template = Flux::Parsing::parse_template_begin( source );
	DefinitionFlags modifiers = Flux::Parsing::parse_modifiers( source );
	Position position = source.lexer:get().position;

	if modifiers.is_public_set && !modifiers.is_static && !modifiers.is_const && source.file.lexer:skip( Symbol, ":" ) {
		if !source.file.context:get_flag "is_root_level"
			source:error( "cannot set global public state at function-level", modifiers.public_pos );

		source.file.context.is_global_public = modifiers.is_public;
	}
	else if source.lexer:test( Keyword, "class" )
	     || source.lexer:test( Keyword, "interface" )
		 || source.lexer:test( Keyword, "final" )
		 || source.lexer:test( Keyword, "abstract" ) {
		return Flux::Parsing::parse_class( source, _template, modifiers, position );
	}
	else if source.lexer:skip( Keyword, "enum" ) {
		return Flux::Parsing::parse_enum( source, modifiers, position );
	}
	else {
		return Flux::Parsing::parse_definition( source, _template, modifiers );
	}
}

void parse_class(Source source, TemplateList _template, DefinitionFlags modifiers, Position position) {

}

void parse_enum(Source source, DefinitionFlags modifiers, Position position) {
	if !source.file.context:get_flag "is_root_level"
		source:error( "invalid location to define enum", position );

	if modifiers.is_static
		source:error( "unexpected 'static' before enum definition", modifiers.static_pos );

	if modifiers.is_const
		source:error( "unexpected 'const' before enum definition: enums are implicitly constant", modifiers.const_pos );

	string[] members = [];
	string name = Flux::Parsing::parseName( source )
	           || source:error "expected enum name after 'enum'";

	if !source.file.lexer:skip( Symbol, "{" )
		source:error "expected '{' after enum name";

	repeat {
		members[#members + 1] = source.file.lexer:skipValue( Identifier )
		                     || source:error "expected identifier for enum member";
	}
	while (source.file.lexer:skip( Symbol, "," )
	   || (source.file.lexer:skip( Symbol, ";" ) && !source.file.lexer:test( Symbol, "}" )));

	if !source.file.lexer:skip( Symbol, "}" )
		source:error "expected '}' to close enum body";

	source.file.lexer:skip( Symbol, ";" );
	source.file:push( new Flux::Parsing::EnumDefinition( Flux::Parsing::resolveDefinitionName( source, name ), members, modifiers.is_public, position ) );

	foreach member in members {
		new Flux::Parsing::TemplatedName enum_name( name, [], position );
		new Flux::Parsing::ReferenceExpression enum_lookup( enum_name, position );
		new Flux::Parsing::DotIndex enum_member_lookup( enum_lookup, member, position );

		source.file:push( new Flux::Parsing::Declaration( enum_name, member, position, true, modifiers.is_public, null, enum_member_lookup ) );
	}
}

void parse_definition(Source source, TemplateList _template, DefinitionFlags modifiers) {
	if modifiers.is_public_set && !source.file.context:get_flag "is_root_level"
		source:error( "cannot declare function-level definition as " `concat` (modifiers.is_public && "public" || "private"), modifiers.public_pos );

	TypedName type_name = Flux::Parsing::parse_initial_type_and_name( source );

	if source.lexer:skip( Symbol, "<" ) {
		if type_name.name.name:find "[^%w_]" // i.e. T operator+<X>:f()
			source:error( "invalid template class '" `concat` type_name.name.name `concat` "'", source.file.lexer:peek( -1 ).position );

		TemplatedName[] classes = [];

		repeat {
			classes[#classes + 1] = Flux::Parsing::TemplatedName:parse( source );
		}
		while source.file.lexer:skip( Symbol, "," );

		type_name.name = new Flux::Parsing::TemplatedName( type_name.name.name, classes, type_name.name.position );

		if !source.file.lexer:skip( Symbol, ">" )
			source:error( "expected '>' to end template list" );

		if !source.file.lexer:skip( Symbol, ":" )
			source:error( "expected ':' for method definition" );
		else if source.file.context:get_flag "is_parsing_body"
			source:error( "cannot declare method in class body", source.file.lexer:peek( -1 ).position );

		return Flux::Parsing::parse_method_definition( source, _template, modifiers, type_name );
	}
	else if source.lexer:skip( Symbol, ":" ) {
		if source.file.context:get_flag "is_parsing_body"
			source:error( "cannot declare method in class body", source.file.lexer:peek( -1 ).position );

		if type_name.name.name:find "[^%w_]" // i.e. T operator+:f()
			source:error( "invalid class for method definition '" `concat` type_name.name.name `concat` "'", source.file.lexer:peek( -1 ).position );

		return Flux::Parsing::parse_method_definition( source, _template, modifiers, type_name );
	}
	else if modifiers.is_static {
		source:error( "unexpected 'static' modifier before definition", modifiers.static_pos );
	}
	else if source.lexer:skip( Symbol, "(" ) {
		return Flux::Parsing::parse_function_definition( source, _template, modifiers, type_name );
	}
	else {
		if type_name.name.name:find "[^%w_]"
			source:error( "invalid name for definition '" `concat` type_name.name.name `concat` "'", type_name.name.position );

		return Flux::Parsing::parse_var_definition( source, modifiers, type_name );
	}
}

void parse_method_definition(Source source, TemplateList _template, DefinitionFlags modifiers, TypedName name) {
	string method_name = Flux::Parsing::parseMethodName( source )
	                  || source:error( "expected method name after ':'" );

	if !source.file.lexer:skip( Symbol, "(" )
		source:error( "expected '(' for method parameters" );

	TemplatedName[] parameter_types = [];
	FunctionParameter[] parameters = [];
	FunctionParameter parameter;
	bool is_vararg = false;

	if !modifiers.is_static {
		parameters[1] = new Flux::Parsing::FunctionParameter( name.name, "self" );
		parameter_types[1] = name.name;
	}

	if !source.file.lexer:skip( Symbol, ")" ) {
		while true {
			parameter = Flux::Parsing::FunctionParameter:parse( source, true, parameter );
			parameters[#parameters + 1] = parameter;
			parameter_types[#parameter_types + 1] = parameter.type;

			if parameter.name == "..." {
				if source.file.lexer:test( Symbol, "," )
					source:error( "unexpected ',' after vararg (...) parameter" );
				is_vararg = true;
			}

			if !source.file.lexer:skip( Symbol, "," ) break;
		}

		if !source.file.lexer:skip( Symbol, ")" )
			source:error( "expected ')' to close method parameters" );
	}

	Block body = Flux::Parsing::parseFunctionBody( source, is_vararg );

	new Flux::Parsing::FunctionExpression definition( parameters, name.type, body );

	source.file:push( new Flux::Parsing::MethodDefinition(
		_template, name.type, name.name, method_name, modifiers.is_static,
		modifiers.is_public, parameter_types, definition, is_vararg
	) );
}

void parse_function_definition(Source source, TemplateList _template, DefinitionFlags modifiers, TypedName name) {
	auto start = source.file.lexer:mark();
	bool names_given = false;
	TemplatedName type;

	try {
		type = Flux::Parsing::types::parse(source);
	}
	catch ParserException e {
		if do_throw && !e:find "expected typename"
			throw new ParserException( e );
	}

	if type != null && source.file.lexer:skip( Identifier )
		names_given = true;

	source.file.lexer:jump( start );

	FunctionParameter parameter;
	FunctionParameter[] parameters = [];
	TemplatedName[] parameter_types = [];
	ASTNode[] defaults = [];
	bool defaults_started = false;
	bool is_vararg = false;

	if !source.lexer:skip( Symbol, ")" ) {
		while true {
			parameter = Flux::Parsing::FunctionParameter:parse( source, names_given, parameter );
			parameters[#parameters + 1] = parameter;
			parameter_types[#parameter_types + 1] = parameter.type;

			if source.file.lexer:skip( Symbol, "=" ) {
				if parameter.name == "..."
					source:error( "cannot assign default value to vararg (...) parameter", source.file.lexer:peek( -1 ).position );

				ASTNode default_value = Flux::Parsing::Expression:parse( source );

				table.insert( defaults, 1, default_value );
				defaults_started = true;
			}
			else if defaults_started
				source:error "expected '=' for parameter default value";

			if parameter.name == "..." {
				if source.file.lexer:test( Symbol, "," )
					source:error( "unexpected ',' after vararg (...) parameter" );
				is_vararg = true;
			}

			if !source.file.lexer:skip( Symbol, "," ) break;
		}

		if !source.file.lexer:skip( Symbol, ")" )
			source:error( "expected ')' after function parameters" );
	}

	TemplatedName f_type = (is_vararg && Flux::Parsing::types::vararg_function_type
			                          || Flux::Parsing::types::function_type)
						   ( name.type.position, name.type, parameter_types );

	if source.file.lexer:skip( Symbol, ";" ) {
		new Flux::Parsing::Declaration decl(
			f_type,
			name.name.name,
			name.type.position,
			modifiers.is_const,
			modifiers.is_public,
			_template,
			null);

		source.file:push( decl );
	}
	else if !names_given {
		source:error "expected ';' after nameless parameter function declaration";
	}
	else {
		Block body = Flux::Parsing::parseFunctionBody( source, is_vararg );

		new Flux::Parsing::FunctionExpression definition( parameters, name.type, body );
		new Flux::Parsing::Declaration decl(
			f_type,
			name.name.name,
			name.type.position,
			modifiers.is_const,
			modifiers.is_public,
			_template,
			definition);

		source.file:push( decl );
	}

	foreach i, v in defaults {
		TemplatedName[] overload_parameter_types = [];
		FunctionParameter[] overload_parameters = [];
		ASTNode[] overload_call_parameters = [];

		for (int j = 1; j <= #parameters - i; j++) {
			overload_parameter_types[j] = parameter_types[j];
			overload_parameters[j] = parameters[j];
			overload_call_parameters[j] = new Flux::Parsing::ReferenceExpression(
				new Flux::Parsing::TemplatedName( parameters[j].name, [], parameters[j].type.position ),
				parameters[j].type.position
			);
		}

		overload_call_parameters[#overload_call_parameters + 1] = v;

		TemplatedName overload_f_type =
		    Flux::Parsing::types::function_type( name.type.position, name.type, overload_parameter_types );

		new Flux::Parsing::ReferenceExpression super_ref( name.name );
		new Flux::Parsing::FunctionCall call_to_super( super_ref, overload_call_parameters );
		new Flux::Parsing::ReturnStatement return_statement( call_to_super );
		new Flux::Parsing::Block overload_body( false, null, [return_statement] );
		new Flux::Parsing::FunctionExpression overload_definition( overload_parameters, name.type, overload_body );

		new Flux::Parsing::Declaration overload_decl(
			overload_f_type,
			name.name.name,
			name.type.position,
			modifiers.is_const,
			modifiers.is_public,
			_template,
			overload_definition
		);

		source.file:push( overload_decl );
	}
}

void parse_var_definition(Source source, DefinitionFlags modifiers, TypedName name) {
	Lexer lexer = source.lexer;
	bool is_const = modifiers.is_const;
	bool is_public = modifiers.is_public;

	if name.type.name == "void" {
		source:error( "cannot declare variable type 'void'", name.type.position );
	}

	string str_name = name.name.name;

	while true {
		if lexer:skip( Symbol, "=" ) {
			let expr = Flux::Parsing::Expression:parse( source );

			expr = new Flux::Parsing::AutoCast( expr, name.type );

			source.file:push( new Flux::Parsing::Declaration(
				name.type, Flux::Parsing::resolveDefinitionName( source, str_name ),
				name.position, is_const, is_public, null, expr
			));
		}
		else {
			source.file:push( new Flux::Parsing::Declaration(
				name.type, Flux::Parsing::resolveDefinitionName( source, str_name ),
				name.position, is_const, is_public, null, null
			) );
		}

		if lexer:skip( Symbol, "," ) {
			str_name = lexer:skipValue( Identifier )
			        || source:error "expected variable name after ','";
		}
		else break;
	}

	Flux::Parsing::expectSemicolon( source, "end of definition" );
}

TemplateList parse_template_begin(Source source)
	if source.lexer:skip( Keyword, "template" ) {
		if !source.lexer:skip( Symbol, "<" )
			source:error "expected '<' after 'template'";

		TemplateList _template = Flux::Parsing::TemplateList:parse( source );

		if !source.lexer:skip( Symbol, ">" )
			source:error "expected '>' after template list";

		return _template;
	}
	else return null;

DefinitionFlags parse_modifiers(Source source) {
	DefinitionFlags modifiers = {
		is_public = false;
		is_public_set = false;
		is_static = false;
		is_const = false;
		public_pos = source.file.lexer:get().position;
		static_pos = source.file.lexer:get().position;
		const_pos = source.file.lexer:get().position;
	};
	Lexer lexer = source.lexer;

	if lexer:skip( Keyword, "public" ) {
		modifiers.is_public_set = true;
		modifiers.is_public = true;
		modifiers.static_pos = source.file.lexer:get().position;
		modifiers.const_pos = source.file.lexer:get().position;
	}
	else if lexer:skip( Keyword, "private" ) {
		modifiers.is_public_set = true;
		modifiers.is_public = false;
		modifiers.static_pos = source.file.lexer:get().position;
		modifiers.const_pos = source.file.lexer:get().position;
	}
	else {
		modifiers.is_public_set = false;
		modifiers.is_public = source.file.context.is_global_public;
	}

	if lexer:skip( Keyword, "static" ) {
		modifiers.is_static = true;
		modifiers.const_pos = source.file.lexer:get().position;
	}

	if lexer:skip( Keyword, "const" )
		modifiers.is_const = true;

	return modifiers;
}

TypedName parse_initial_type_and_name(Source source) {
	// A:A() -> void A leaving colon
	// ClassName() -> void ClassName
	// int x -> int x

	Lexer lexer = source.lexer;
	Position position = lexer:get().position;

	if source.file.context:get_flag "is_parsing_body" && lexer:skip( Identifier, source.file.context.class_name ) {
		return {
			type = new Flux::Parsing::TemplatedName( "void", [], position );
			name = source.file.context.class_name;
			position = position;
		};
	}
	else {
		string name = lexer:skipValue "Identifier";

		if name {
			if lexer:skip( Symbol, ":" ) {
			 	if lexer:skip( Identifier, name ) {
					lexer:back();
					lexer:back();

					return {
						type = new Flux::Parsing::TemplatedName( "void", [], position );
						name = new Flux::Parsing::TemplatedName( name, [], position );
						position = position;
					};
				}

				lexer:back();
			}

			lexer:back();
		}

		TemplatedName type = source.file.lexer:test( Keyword, "void" )
		                  && new Flux::Parsing::TemplatedName( "void", [], source.file.lexer:next().position )
		                  || Flux::Parsing::types::parse( source );
		Position pos = source.file.lexer:get().position;
		new Flux::Parsing::TemplatedName name( Flux::Parsing::parseMethodName( source )
			|| source:error( "expected variable/function name after type" ), [], pos );

		return {
			type = type;
			name = name;
			position = position;
		};
	}
}
