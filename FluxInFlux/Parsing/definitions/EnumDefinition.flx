
namespace Flux::Parsing;

bool EnumDefinition:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if !source.context.isNamespace || !lexer:skip( Keyword, "enum" ) return false;
	
	string name = Flux::Parsing::resolveDefinitionName( source, Flux::Parsing::parseName( source ) || source:error "expected enum name after 'enum'" );
	string[] members = [];

	if !lexer:skip( Symbol, "{" ) source:error "expected '{' after enum name";

	repeat
		members[#members + 1] = lexer:skipValue( Identifier ) || source:error "expected name in enum body";
	while (lexer:skip( Symbol, "," ) || lexer:skip( Symbol, ";" ) && !lexer:test( Symbol, "}" ));

	if !lexer:skip( Symbol, "}" ) source:error "expected '}' after enum body";

	source:push( new Flux::Parsing::EnumDefinition( name, members, position ) );

	let enum_type = new Flux::Parsing::Type( name, [], position );
	let enum_ref = new Flux::Parsing::ReferenceExpression( name, position );

	foreach member in members {
		let name = Flux::Parsing::resolveDefinitionName( source, member );
		let member_index = new Flux::Parsing::DotIndex( enum_ref, member );
		source:push( new Flux::Parsing::Definition( enum_type, null, name, member_index, true, position ) );
	}

	return true;
}

string EnumDefinition:serialize()
	= "enum " `concat` self.name `concat` " {\n\t" `concat` table.concat( self.members, ";\n\t" ) `concat` ";\n}";
