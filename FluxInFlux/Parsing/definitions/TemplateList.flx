
namespace Flux::Parsing;

class TemplateList {
	string[] names;
	TemplatedName[][] classes;
	Position position;

	TemplateList(string[] names, TemplatedName[][] classes, Position position) {
		self.names = names;
		self.classes = classes;
		self.position = position;
	}

	TemplateList parse(Source source, Position position);
	string serialize();
}

TemplateList TemplateList:parse(Source source, Position position) {
	Lexer lexer = source.lexer;
	string[] names = [];
	TemplatedName[][] classes = [];

	repeat {
		names[#names + 1] = lexer:skipValue( Identifier ) || source:error "expected template type name";
		TemplatedName[] classes_local = [];

		if lexer:skip( Symbol, "[" ) {
			repeat
				classes_local[#classes_local + 1] = Flux::Parsing::TemplatedName:parse( source );
			while lexer:skip( Symbol, "," );

			if !lexer:skip( Symbol, "]" ) source:error "expected ']'";
		}

		classes[#classes + 1] = classes_local;
	}
	while lexer:skip( Symbol, "," );

	return new Flux::Parsing::TemplateList( names, classes, position );
}

string TemplateList:serialize() {
	string[] s = [];

	foreach i, name in self.names {
		s[i] = name `concat` (#self.classes[i] > 0 && " [" `concat` (self.classes[i] `concattenate` ", ") `concat` "]" || "");
	}

	return table.concat( s, ", " );
}
