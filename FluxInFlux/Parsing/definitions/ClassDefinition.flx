
namespace Flux::Parsing;

bool ClassDefinition:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	TemplateList _template;

	// read a template
	if lexer:skip( Keyword, "template" ) {
		if !lexer:skip( Symbol, "<" ) source:error "expected '<' after 'template'";
		_template = Flux::Parsing::TemplateList:parse( source );
		if !lexer:skip( Symbol, ">" ) source:error "expected '>' after template list";
	}

	if !lexer:skip( Keyword, "class" )
		if _template
			source:error( "expected definition after template" );
		else return false;

	// probably remove this? why limit classes to the main body of a file?
	if !source.context.isNamespace
		source:error "invalid section to define class";
	
	Type name = Flux::Parsing::Type:parse( source );
	Type _extends;
	Type[] container;
	string[] _implements = [];

	name.name = Flux::Parsing::resolveDefinitionName( source, name.name );

	if lexer:skip( Symbol, "(" ) {
		let t1 = Flux::Parsing::Type:parse( source );
		if lexer:skip( Symbol, "," )
			container = [t1, Flux::Parsing::Type:parse( source )];
		else
			container = [t1];
		if !lexer:skip( Symbol, ")" ) source:error "expected ')' to close container";
	}

	_extends = lexer:skip( Keyword, "extends" ) && Flux::Parsing::Type:parse( source );
	
	if lexer:skip( Keyword, "implements" )
		repeat {
			_implements[#_implements + 1] = Flux::Parsing::parseName( source ) || source:error "expected interface name";
		}
		while lexer:skip( Symbol, "," );

	if !lexer:skip( Symbol, "{" )
		source:error "expected '{' for class body";

	source:pushClassContext(name);
	source:pushBlock();

	while !lexer:skip( Symbol, "}" ) {
		if lexer:isEOF() source:error "expected '}' to close class body";

		if (lexer:test( Keyword, "public" ) || lexer:test( Keyword, "private" )) && lexer:test( Symbol, ":", 1 ) {
			source.context:setPublic( lexer:skip( Keyword, "public" ) && true || lexer:skip( Keyword, "private" ) && false );
			lexer:next();
		}
		else
			Flux::Parsing::Definition:parse( source ) || source:error "expected definition";
	}

	source:popContext();

	let definitions = source:popBlock();

	ClassMember[] members = [];

	foreach definition in definitions {
		members[#members + 1] = new Flux::Parsing::ClassMember( definition );
	}

	source:push( new Flux::Parsing::ClassDefinition( name, container, _extends, _implements, _template, members, position ) );
	
	/*foreach definition in definitions {
		if definition.type == Flux::Parsing::ASTNodeType.TemplateDefinition {
			if definition.value
				source:push( new Flux::Parsing::TemplateDefinition(
					definition._type, name, definition.name, definition.value, false, false, false, definition._template, definition.position ) );
		}
		else
			if definition.value
				source:push( new Flux::Parsing::Definition(
					definition._type, selftype, definition.name, definition.value, false, false, false, definition.position ) );
	}*/

	return true;
}

string ClassDefinition:serialize()
	= (self._template && "template <" `concat` self._template:serialize() `concat` ">\n" || "")
		`concat` "class " `concat` self.name:serialize()
		`concat` (self.container && " (" `concat` self.container[1]:serialize() `concat` ", " `concat` self.container[2]:serialize() `concat` ")" || "")
		`concat` (self._extends && " extends " `concat` self._extends:serialize() || "")
		`concat` (#self._implements > 0 && " implements " `concat` table.concat(self._implements, ", ") || "")
		`concat` " {\n\t" `concat` (self.members `concattenate` "\n\t") `concat` "\n}";
