
namespace Flux::Parsing;

bool ClassDefinition:parse(Source source) {
	let lexer = source.lexer;

	int start = lexer:mark();
	bool isConst, isFinal, isAbstract;
	string[] flags = [];
	TemplateList _template;
	Position template_position = lexer:get().position;

	while lexer:skip( Instruction, "flagcdef" )
		flags[#flags + 1] = Flux::Parsing::parseInstructionOperand( lexer );

	// read a template
	if lexer:skip( Keyword, "template" ) {
		if !lexer:skip( Symbol, "<" ) source:error "expected '<' after 'template'";
		_template = Flux::Parsing::TemplateList:parse( source );
		if !lexer:skip( Symbol, ">" ) source:error "expected '>' after template list";
	}

	isConst = lexer:skip( Keyword, "const" ) && true || false;
	isFinal = lexer:skip( Keyword, "final" ) && true || false;
	isAbstract = lexer:skip( Keyword, "abstract" ) && true || false;

	Position position = lexer:get().position;

	if !lexer:skip( Keyword, "class" ) {
		if #flags > 0
			source:error "expected class definition";
		else if _template
			lexer:jump( start );
		return false;
	}

	if !_template
		_template = new Flux::Parsing::TemplateList([], []);

	// probably remove this? why limit classes to the main body of a file?
	if !source.context.isNamespace
		source:error "invalid section to define class";

	source:pushClassnameContext();
	
	Type name = Flux::Parsing::Type:parse( source );
	Type _extends;
	Type[] container;
	string[] _implements = [];

	source:popContext();

	name.name = Flux::Parsing::resolveDefinitionName( source, name.name );

	if lexer:test( Symbol, ";" ) {
		if #flags > 0
			source:error "expected class body: cannot give flags to class declarations";
		else if isConst
			source:error "expected class body: cannot declare class declaration const";
		else if isFinal
			source:error "expected class body: cannot declare class declaration final";
		else if isAbstract
			source:error "expected class body: cannot declare class declaration abstract";

		lexer:next();
		source:push( new Flux::Parsing::ClassDeclaration( name, _template, position ) );

		return true;
	}

	// for `class intlist = int[];`
	if lexer:skip( Symbol, "=" ) {
		let type = Flux::Parsing::Type:parse( source );

		Flux::Parsing::expectSemicolon( source, "end of class type" );

		source:push( new Flux::Parsing::AliasClassDefinition( name, _template, [type], position ) );

		return true;
	}
	// for `class number [float, int]`
	else if lexer:skip( Symbol, "[" ) {
		Type[] types = [];

		repeat {
			types[#types + 1] = Flux::Parsing::Type:parse( source );
		}
		while lexer:skip( Symbol, "," );

		if !lexer:skip( Symbol, "]" )
			source:error "expected ']' after type list";

		source:push( new Flux::Parsing::AliasClassDefinition( name, _template, types, position ) );

		return true;
	}

	if lexer:skip( Symbol, "(" ) {
		let t1 = Flux::Parsing::Type:parse( source );
		if lexer:skip( Symbol, "," )
			container = [t1, Flux::Parsing::Type:parse( source )];
		else
			container = [t1];
		if !lexer:skip( Symbol, ")" ) source:error "expected ')' to close container";
	}

	source:pushClassnameContext();
	_extends = lexer:skip( Keyword, "extends" ) && Flux::Parsing::Type:parse( source );
	source:popContext();
	
	if lexer:skip( Keyword, "implements" )
		repeat {
			_implements[#_implements + 1] = Flux::Parsing::parseName( source )
			    || source:error "expected interface name";
		}
		while lexer:skip( Symbol, "," );

	if !lexer:skip( Symbol, "{" )
		source:error "expected '{' for class body";

	source:pushClassContext(name);
	source:pushBlock();

	while !lexer:skip( Symbol, "}" ) {
		if lexer:isEOF() source:error "expected '}' to close class body";

		if (lexer:test( Keyword, "public" ) || lexer:test( Keyword, "private" ))
			&& lexer:test( Symbol, ":", 1 ) {
			source.context:setPublic(
				   lexer:skip( Keyword, "public" ) && true
				|| lexer:skip( Keyword, "private" ) && false );
			lexer:next();
		}
		else
			Flux::Parsing::Definition:parse( source ) || source:error "expected definition in class body";
	}

	source:popContext();

	let definitions = source:popBlock();

	ClassMember[] members = [];

	source:push( new Flux::Parsing::ClassDefinition(
		name, container, _extends, _implements, _template, members, isConst, isFinal, isAbstract, flags, position
	) );
	
	foreach definition in definitions {
		Definition raw_def;

		// if the definition is a normal definition, it needs a template added to it
		if definition.type == Flux::Parsing::ASTNodeType.Definition && #_template.names > 0 {
			definition = new Flux::Parsing::TemplateDefinition(definition, _template, template_position);
			raw_def = definition.definition;
		}
		// if the definition is a templated definition, add the class template params to it
		else if #_template.names > 0 {
			for (int i = #_template.names, i > 0, i--) {
				table.insert( definition.template_list.names, 1, _template.names[i] );
				table.insert( definition.template_list.classes, 1, _template.classes[i] );
			}
			raw_def = definition.definition;
		}
		// if the class has no template
		else
			raw_def = definition;

		members[#members + 1] = new Flux::Parsing::ClassMember( definition );

		raw_def._class = name;

		if raw_def.value
			source:push( definition );
	}

	return true;
}

string ClassDefinition:serialize()
	= (#self.flags > 0 && "@flagcdef " `concat` table.concat( self.flags, "\n@flagcdef " ) `concat` "\n" || "")
		`concat` "template <" `concat` self._template:serialize() `concat` ">\n"
		`concat` (self.isConst && "const " || "")
		`concat` (self.isFinal && "final " || "")
		`concat` (self.isAbstract && "abstract " || "")
		`concat` "class " `concat` self.name:serialize()
		`concat` (self.container && " (" `concat` self.container[1]:serialize() `concat` ", "
		`concat` self.container[2]:serialize() `concat` ")" || "")
		`concat` (self._extends && " extends " `concat` self._extends:serialize() || "")
		`concat` (#self._implements > 0 && " implements " `concat` table.concat(self._implements, ", ") || "")
		`concat` " {\n\t" `concat` (self.members `concattenate` "\n\t") `concat` "\n}";
