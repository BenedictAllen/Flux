
namespace Flux::Parsing;

// TODO
// Definition:parse() should handle *all* definitions
// That's classes, interfaces, enums, functions, and variables
// Ouch, right?

/* Method

	collect definition flags (Instruction "flagdef")
	parse template if present : track position
	parse modifier#1 (public/private)
	parse modifier#2 (static/final/abstract)
		specialise definition type to class if final/abstract
		err if class specialised && in class/interface body
	parse modifier#3 (const) : track position
	if 'class' or 'interface' skipped
		use class/interface parser
	if 'enum' skipped
		use enum parser
	else
		use generic definition parser

*/

/*
bool Definition:parse(Source source) {
	Lexer lexer = source.lexer;
	int start = lexer:mark();
	// whether we're parsing inside the body of a class/interface
	bool isClassDef = source.context.isInterface || source.context.isClass;
	// whether the function defines a foreign function (used to decide if 'void' is a valid body)
	bool hasForeignFunction = false;
	// the classname without namespace
	string classname = isClassDef && source.context.class_name.name:gsub( ".+::", "" );
	// a list of all definition flags
	string[] flags = [];
	// the absolute start position
	Position position = lexer:get().position;
	// a list of template options if it's a templated definition
	TemplateList _template;

	while lexer:skip(Instruction, "flagdef")
		flags[#flags + 1] = Flux::Parsing::parseInstructionOperand( lexer );

	// read a template
	if lexer:skip( Keyword, "template" ) {
		if !lexer:skip( Symbol, "<" ) source:error "expected '<' after 'template'";
		_template = Flux::Parsing::TemplateList:parse( source );
		if !lexer:skip( Symbol, ">" ) source:error "expected '>' after template list";
	}

	// inherit public state from class context (public: private: can change it)
	bool isPublic = (source.context.isInterface || source.context.isClass) && source.context.isPublic || DEFAULT_PUBLIC;

	// modify public state if respective keyword found
	if lexer:skip( Keyword, "public" )
		isPublic = true;
	else if lexer:skip( Keyword, "private" )
		isPublic = false;

	// determine if static and/or constant
	bool isStatic = isClassDef && lexer:skip( Keyword, "static" ) && true || false;
	bool isConst = lexer:skip( Keyword, "const" ) && true || false;

	int pretype_marker = lexer:mark();

	// '_type' is the return type/value type
	Type _type;
	// 'name' is the name of the function/variable
	string name;
	// '_class' is the container class the function/variable is being added to, if any
	Type _class;

	int _mark = lexer:mark();

	// if inside a class definition and constructor name given followed by '('
	if isClassDef && lexer:skip( Identifier, classname ) && lexer:test( Symbol, "(" ) {
		_type = Flux::Parsing::Type:voidType( position );
		name = classname;
	}
	// otherwise, read the type like usual
	else {
		lexer:jump( _mark );
		try {
			_type = Flux::Parsing::Type:parse( source );
		}
		catch ParserException e {}
	}

	let _mark = lexer:mark();

	// allow for Button:Button(int x, y) {} rather than void Button:Button(int x, y) {}
	// if a ':' and method name matching the already parsed type is found after, it's probably a constructor definition
	// note, this'll break any static Button:Button() calls: might need to fix in the future
	// then again, can it be fixed? it might just need to be a syntax flaw
	if !isClassDef && _type && lexer:skip( Symbol, ":" ) && lexer:skip( Identifier, _type.name:gsub( ".+::", "" ) ) {
		// the method name can't contain the namespace the class is it, hence the gsub()
		name = _type.name:gsub( ".+::", "" );
		// set the 'containing class' to the type given
		_class = _type;
		// constructors return void
		_type = Flux::Parsing::Type:voidType( _type.position );
	}
	else lexer:jump( _mark );

	// allow for 'void' return type
	if !_type && lexer:test(Keyword, "void")
		_type = Flux::Parsing::Type:voidType( lexer:next().value );

	name = _type && (name || isClassDef && Flux::Parsing::parseMethodName( source ) || Flux::Parsing::parseName( source ));

	// if a type wasn't given or there isn't a name next, it's not a definition
	if !_type || !name {
		bool testClass = lexer:test( Keyword, "class" )
		              || lexer:test( Keyword, "interface" )
		              || lexer:test( Keyword, "final" )
		              || lexer:test( Keyword, "abstract" );
		lexer:jump( pretype_marker );

		if _template && !testClass
			source:error "expected definition after 'template'";
		else if #flags > 0
			source:error "expected definition after definition flags given";

		lexer:jump( start );
		// same for public/private/static
		return false;
	}

	repeat {
		Expression value;
		Position start = lexer:get().position;
		int _mark = lexer:mark();

		if _class {
			// if a method is defined in the class, error
			if isClassDef && lexer:test( Symbol, ":" )
				if source.context.isClass
					source:error "unexpected ':' for method name in class member definition";
				else
					source:error "unexpected ':' for method name in interface member definition";
		}
		else {
			name = name || Flux::Parsing::parseMethodName(source) || source:error "expected definition name";

			// error if there's a colon (for a method) after an operator name
			if name:find "[^%w_:]" && lexer:test( Symbol, ":" )
				source:error "unexpected ':' after operator name";

			// if we're adding a method to a template class
			if !name:find "[^%w_:]" && lexer:test( Symbol, "<" ) {
				if source.context.isClass
					source:error "unexpected '<' in class member definition";
				if source.context.isInterface
					source:error "unexpected '<' in interface member definition";

				// jump back and re-read the name as a type
				lexer:jump( _mark );
				_class = Flux::Parsing::Type:parse( source );

				// expect a ':' as `void f<T>();` is invalid
				if !lexer:skip( Symbol, ":" )
					source:error "expected ':' after class template";

				name = Flux::Parsing::parseMethodName(source) || source:error "expected method name after ':'";
			}
		}

		if lexer:skip( Symbol, "(" ) { // function definition
			FunctionParameter[] parameters = [];
			Type[] parameter_types = [];
			Expression[] defaults = [];
			FunctionParameter parameter;
			bool parameterNamesGiven = true;
			bool defaults_started = false;

			if source.context.isClass && !isStatic {
				parameters[1] = new Flux::Parsing::FunctionParameter(source.context.class_name, "self");
				parameter_types[1] = source.context.class_name;
			}

			if (name == classname || _class && name == _class.name) && _type.name != "void"
				source:error( "expected return type of void for constructor", _type.position );

			if !lexer:skip( Symbol, ")" ) { // if it takes arguments
				let _mark = lexer:mark();
				// test for a partial definition i.e. int f(int)
				try
					if (lexer:skip( Keyword, "auto" ) || Flux::Parsing::Type:parse( source )) && (lexer:skip( Symbol, "=" ) || lexer:skip( Symbol, "," ) || lexer:skip( Symbol, ")" ))
						parameterNamesGiven = false;
				catch ParserException e {}

				lexer:jump( _mark );
				int n = source.context.isClass && 1 || 0;
				Type last_type;

				if !parameterNamesGiven && source.context.isClass && !isStatic
					parameters[1].name = "a";

				repeat { // parse parameters
					parameter = Flux::Parsing::FunctionParameter:parse(source, parameterNamesGiven, parameter);
					parameters[#parameters + 1] = parameter;
					parameter_types[#parameter_types + 1] = parameter._type;

					if lexer:test( Symbol, "=" ) && _class
						source:error "defaults aren't allowed when defining methods";

					let default_value = lexer:skip( Symbol, "=" ) && (Flux::Parsing::Expression:parse(source) || source:error "expected expression after '='");

					if default_value {
						defaults_started = true;
						defaults[#defaults + 1] = default_value;
					}
					else if defaults_started // defaults must be consecutively at the end of definition parameters
						source:error "expected '=' for default value";
				}
				while lexer:skip( Symbol, "," );

				if !lexer:skip( Symbol, ")" )
					source:error "expected ')' to close function parameters";
			}

			// if it's a method, you can't exactly predeclare it, so it expects a body
			if _class && lexer:test( Symbol, ";" ) source:error "expected function body after method";
			// if the parameter names weren't given, you can't use them, so it won't let you define a body
			if !parameterNamesGiven && !lexer:test( Symbol, ";" ) && !lexer:test( Keyword, "void" )
				source:error "expected ';' after partial function declaration";
			
			Block body;

			if lexer:skip( Keyword, "void" )
				if !hasForeignFunction
					source:error "unexpected keyword 'void' after non-foreign function";
				else {
					body = new Flux::Parsing::Block([], lexer:peek(-1).position, true);
					if !lexer:skip( Symbol, ";" )
						source:error "expected ';' after void body";
				}
			else {
				body = !lexer:skip( Symbol, ";" ) && Flux::Parsing::parseFunctionBody( source );
			}

			let value = body && new Flux::Parsing::FunctionExpression( parameters, _type, body, start );
			let function_type = new Flux::Parsing::Type:functionType( start, _type, parameter_types );
			let def_name = _class && name || Flux::Parsing::resolveDefinitionName( source, name );
			let definition = new Flux::Parsing::Definition( function_type, _class, def_name, value, isConst, isPublic, isStatic, flags, start );

			if _template
				source:push( new Flux::Parsing::TemplateDefinition( definition, _template, position ) );
			else
				source:push( definition );

			// create the overloads for the default parameters, each one calling the 'parent' function
			if defaults_started {
				foreach i in 1 .. #defaults {
					Type function_type;
					Expression value;

					Type[] partial_parameter_types = [];
					FunctionParameter[] partial_parameters = [];
					Expression[] call_parameters = [];

					foreach n in 1 .. #parameter_types - i { // add parameters up to the default for the overload currently being created
						partial_parameter_types[n] = parameter_types[n];
						partial_parameters[n] = parameters[n];
						call_parameters[n] = new Flux::Parsing::ReferenceExpression( parameters[n].name, parameters[n].position );
					}

					// loop this to include *all* the default parameters past #defaults-i+1?
					// foreach n in #defaults - i + 1 .. #defaults
					//	call_parameters[#call_parameters + 1] = defaults[n];
					// by looping, it gets rid of T f(T a = 0, b = a) potential
					// so use the one-at-a-time approach and mark const
					call_parameters[#call_parameters + 1] = defaults[#defaults - i + 1];

					let function_ref = new Flux::Parsing::ReferenceExpression( def_name, start ); // reference to main function
					let function_call = new Flux::Parsing::FunctionCall( function_ref, call_parameters ); // calling the main function
					let body = new Flux::Parsing::Block( [new Flux::Parsing::ReturnStatement( function_call )], start ); // block containing return of above
					let function_type = new Flux::Parsing::Type:functionType( start, _type, partial_parameter_types ); // type of overload
					let value = new Flux::Parsing::FunctionExpression( partial_parameters, _type, body, start ); // the function value containing the call to main function
					let definition = new Flux::Parsing::Definition( function_type, _class, def_name, value, true, isPublic, isStatic, [], start );

					if _template
						source:push( new Flux::Parsing::TemplateDefinition( definition, _template, position ) ); // push the overload
					else
						source:push( definition ); // push the overload
				}
			}

			return true;
		}
		else if _template
			source:error "expected '(' for function parameters after template";
		else if name:find "^setter " || name:find "^getter "
			source:error( "expected '(' for function parameters after " `concat` name:sub( 1, 1 ) `concat` "etter name" );
		else if name:find "[^%w_:]"
			source:error "expected '(' for function parameters after operator name";
		else if isClassDef && name == classname
			source:error "expected '(' for function parameters after constructor name";
		else if _class
			source:error "expected '(' for function parameters after method name";
		else if _type.name == "void"
			source:error "expected '(' for function parameters after void return type";
		else {
			value = lexer:skip(Symbol, "=") && (Flux::Parsing::Expression:parse( source ) || source:error "expected definition after '='");
			source:push( new Flux::Parsing::Definition( _type, null, Flux::Parsing::resolveDefinitionName( source, name ), value, isConst, isPublic, isStatic, flags, start ) );
		}

		name = null;
	}
	while lexer:skip( Symbol, "," );

	if !Flux::Parsing::parseSemicolon( lexer )
		source:error "expected ';' after definition(s)";

	return true;
}

*/

string Definition:serialize()
	= (#self.flags > 0 && "@flagdef " `concat` table.concat( self.flags, "\n@flagdef " ) `concat` "\n" || "")
		`concat` (self.isConst && "const " || "")
		`concat` (self._type:serialize() `concat` " ")
		`concat` (self._class && self._class:serialize() `concat` ":" || "")
		`concat` (self.name)
		`concat` (self.value && " = " `concat` self.value:serialize() || "") `concat` ";";
