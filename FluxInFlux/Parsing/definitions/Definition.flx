
import FunctionParameter;

namespace Flux::Parsing;

class Definition extends ASTNode {
	ASTNodeType type = Flux::Parsing::ASTNodeType.Definition;
	Type _type;
	string name;
	Expression value;
	bool isConst;
	
	Definition(Type _type, string name, null Expression value, bool isConst, Position position) {
		self._type = _type;
		self.name = name;
		self.value = value;
		self.isConst = isConst;
		self.position = position;
	}
}

bool Definition:parse(Source source) {
	let lexer = source.lexer;
	let start = lexer:mark();
	let isConst = lexer:skip( Keyword, "const" );
	
	Type _type;

	try {
		_type = Flux::Parsing::Type:parse( source );
	}
	catch ParserException e {}

	if !_type || !lexer:test(Identifier) && !lexer:test(Keyword, "operator") {
		lexer:jump( start );
		if isConst {
			lexer:next();
			source:error "expected definition after 'const'";
		}
		return false;
	}

	repeat {
		Position start;
		string name;
		Expression value;

		start = lexer:get().position;
		name = Flux::Parsing::parseMethodName(source);

		if lexer:skip( Symbol, "(" ) { // function definition
			FunctionParameter[] parameters = [];
			Type[] parameter_types = [];
			FunctionParameter parameter;

			if !lexer:skip( Symbol, ")" ) {
				repeat {
					parameter = Flux::Parsing::FunctionParameter:parse(source, parameter);
					parameters[#parameters + 1] = parameter;
					parameter_types[#parameter_types + 1] = parameter._type;
				}
				while lexer:skip( Symbol, "," );

				if !lexer:skip( Symbol, ")" )
					source:error "expected ')' to close function parameters";
			}

			let body = Flux::Parsing::parseFunctionBody( source );
			let function_type = new Flux::Parsing::FunctionType(_type, parameter_types);
			let value = new Flux::Parsing::FunctionExpression( parameters, _type, body, start );

			source:push( new Flux::Parsing::Definition( function_type, name, value, isConst, start ) );

			return true;
		}
		else if name:find "[^%w_]"
			source:error "expected '(' for function parameters after operator name";
		else {
			value = lexer:skip(Symbol, "=") && Flux::Parsing::Expression:parse( source );
			source:push( new Flux::Parsing::Definition( _type, name, value, isConst, start ) );
		}
	}
	while lexer:skip( Symbol, "," );

	if !lexer:skip( Symbol, ";" )
		source:error "expected ';' after definition(s)";

	return true;
}

string Definition:serialize() {
	return (self.isConst && "const " || "")
		`concat` self._type:serialize()
		`concat` " " `concat` self.name
		`concat` (self.value && " = " `concat` self.value:serialize() || "")
		`concat` ";";
}
