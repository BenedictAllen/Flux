
namespace Flux::Parsing;

bool Definition:parse(Source source) {
	let lexer = source.lexer;
	let start = lexer:mark();
	let isClassDef = source.context.isInterface || source.context.isClass;
	let classname = source.context.isClass && source.context.class_name:gsub( ".+::", "" );

	TemplateList _template;

	if lexer:skip( Keyword, "template" ) {
		if !lexer:skip( Symbol, "<" ) source:error "expected '<' after 'template'";
		_template = Flux::Parsing::TemplateList:parse( source );
		if !lexer:skip( Symbol, ">" ) source:error "expected '>' after template list";
	}

	bool isPublic = (source.context.isInterface || source.context.isClass) && source.context.isPublic;

	if isClassDef && lexer:skip( Keyword, "public" )
		isPublic = true;
	else if isClassDef && lexer:skip( Keyword, "private" )
		isPublic = false;

	bool isStatic = source.context.isClass && lexer:skip( Keyword, "static" ) && true || false;
	bool isConst = lexer:skip( Keyword, "const" ) && true || false;
	Type _type;
	string method, name;
	int _mark = lexer:mark();
	Type _class;

	if source.context.isClass && lexer:skip( Identifier, classname ) && lexer:test( Symbol, "(" ) {
		_type = new Flux::Parsing::Typename( "void", position );
		name = source.context.class_name:gsub( ".+::", "" );
	}
	else {
		lexer:jump( _mark );
		try {
			_type = Flux::Parsing::Type:parse( source );
		}
		catch ParserException e {}
	}

	let _mark = lexer:mark();

	// allow for Button:Button(int x, y) {} rather than void Button:Button(int x, y) {}
	// if the type is a typename, and a : and correct method name is found after, it's probably a constructor definition
	// note, this'll break any static Button:Button() calls, might need to fix in the future
	// then again, can it be fixed? it might just need to be a syntax flaw
	if !isClassDef && _type && _type.type == Flux::Parsing::ASTNodeType.Typename && lexer:skip( Symbol, ":" ) && lexer:skip( Identifier, _type.name:gsub( ".+::", "" ) ) {
		_class = _type;
		name = _type.name:gsub( ".+::", "" ); // the method name can't contain the namespace the class is it, hence the gsub()
		_type = new Flux::Parsing::Typename( "void", _type.position ); // constructors return void... or self? maybe self... maybe change this, it'll make object creation more inline when compiled, and do stuff with the returns in constructor...?
	}
	else if !isClassDef && _type && _type.type == Flux::Parsing::ASTNodeType.TemplatedType && lexer:skip( Symbol, ":" ) && lexer:skip( Identifier, _type.name:gsub( ".+::", "" ) ) {
		_class = _type;
		name = _type.name:gsub( ".+::", "" ); // the method name can't contain the namespace the class is it, hence the gsub()
		_type = new Flux::Parsing::Typename( "void", _type.position ); // constructors return void... or self? maybe self... maybe change this, it'll make object creation more inline when compiled, and do stuff with the returns in constructor...?
	}
	else lexer:jump( _mark );

	// allow for 'void' return type
	if !_type && lexer:test(Keyword, "void")
		_type = new Flux::Parsing::Typename("void", lexer:next().value);
	// no need to put this above the constructor test as you can't have a class called 'void' anyway

	// if a type wasn't given or there isn't a name next, it's not a definition
	if !_type || (!name && !lexer:test(Identifier) && !lexer:test(Keyword, "operator") && (!isClassDef || !lexer:test( Keyword, "setter" ) && !lexer:test( Keyword, "getter" ))) {
		lexer:jump( start );
		if _template {
			lexer:next();
			source:error "expected definition after 'template'";
		}
		else if isConst {
			lexer:next();
			source:error "expected definition after 'const'";
		}
		return false;
	}

	repeat {
		Position start;
		Expression value;
		int _mark;

		start = lexer:get().position;
		_mark = lexer:mark();

		if !_class {
			name = name || Flux::Parsing::parseMethodName(source);

			// error if there's a colon (for a method) after an operator name
			if name:find "[^%w_:]" && lexer:test( Symbol, ":" )
				source:error "unexpected ':' after operator name";

			// if we're adding a method to a template class
			if !method && !name:find "[^%w_:]" && lexer:test( Symbol, "<" ) {
				if source.context.isClass
					source:error "unexpected '<' in class member definition";
				if source.context.isInterface
					source:error "unexpected '<' in interface member definition";

				lexer:jump( _mark );
				_class = Flux::Parsing::Type:parse( source );

				if !lexer:skip( Symbol, ":" )
					source:error "expected ':' after class template";

				name = Flux::Parsing::parseMethodName(source);
				method = "";
			}
		}
		// otherwise
		else {
			// if a method is defined, swap the name and method and define the class being modified
			if !method && isClassDef && lexer:test( Symbol, ":" )
				if source.context.isClass
					source:error "unexpected ':' for method name in class member definition";
				else
					source:error "unexpected ':' for method name in interface member definition";

			method = method || lexer:skip( Symbol, ":" ) && Flux::Parsing::parseMethodName(source);

			if method {
				_class = new Flux::Parsing::Typename( name, start );
				name = method || lexer:skip( Symbol, ":" ) && Flux::Parsing::parseMethodName(source);
			}
		}

		if lexer:skip( Symbol, "(" ) { // function definition
			FunctionParameter[] parameters = [];
			Type[] parameter_types = [];
			bool[] parameter_nullables = [];
			Expression[] defaults = [];
			FunctionParameter parameter;
			bool parameterNamesGiven = true;
			bool defaults_started = false;

			if name == classname && (_type.type != Flux::Parsing::ASTNodeType.Typename || _type.name != "void")
				source:error( "expected return type of void for constructor", _type.position );

			if !lexer:skip( Symbol, ")" ) { // if it takes arguments
				let _mark = lexer:mark(); // below: test for a partial definition i.e. int f(int)
				if !method && (lexer:skip( Keyword, "void" ) && true || true) && (lexer:skip( Keyword, "auto" ) || lexer:skip( Identifier )) && (lexer:skip( Symbol, "=" ) || lexer:skip( Symbol, "," ) || lexer:skip( Symbol, ")" )) {
					lexer:jump( _mark );
					parameterNamesGiven = false;
					int n = 0;
					Type last_type;

					repeat { // get partial parameters, generating names for each parameter
						let pos = lexer:get().position;
						let nullable = lexer:skip( Keyword, "null" ) && true || false;
						let type = (lexer:test( Symbol, "=" ) || lexer:test( Symbol, "," ) || lexer:test( Symbol, ")")) && last_type || Flux::Parsing::Type:parse( source );
						let name = Flux::Parsing::intToName( n++ );

						if lexer:test( Symbol, "=" ) && method
							source:error "defaults aren't allowed when defining methods";

						let default_value = lexer:skip( Symbol, "=" ) && (Flux::Parsing::Expression:parse(source) || source:error "expected expression after '='");

						if default_value {
							defaults_started = true;
							defaults[#defaults + 1] = default_value;
						}
						else if defaults_started // defaults must be consecutively at the end of definition parameters
							source:error "expected '=' for default value";

						parameters[#parameters + 1] = new Flux::Parsing::FunctionParameter(type, name, nullable, pos);
						parameter_types[#parameter_types + 1] = type;
						parameter_nullables[#parameter_nullables + 1] = nullable;
						last_type = type;
					}
					while lexer:skip( Symbol, "," );
				}
				else { // otherwise, a full definition, i.e. int f(int x)
					lexer:jump( _mark );
					repeat { // parse parameters
						parameter = Flux::Parsing::FunctionParameter:parse(source, parameter);
						parameters[#parameters + 1] = parameter;
						parameter_types[#parameter_types + 1] = parameter._type;
						parameter_nullables[#parameter_nullables + 1] = parameter.nullable;

						if lexer:test( Symbol, "=" ) && method
							source:error "defaults aren't allowed when defining methods";

						let default_value = lexer:skip( Symbol, "=" ) && (Flux::Parsing::Expression:parse(source) || source:error "expected expression after '='");

						if default_value {
							defaults_started = true;
							defaults[#defaults + 1] = default_value;
						}
						else if defaults_started // defaults must be consecutively at the end of definition parameters
							source:error "expected '=' for default value";
					}
					while lexer:skip( Symbol, "," );
				}

				if !lexer:skip( Symbol, ")" )
					source:error "expected ')' to close function parameters";
			}

			// if it's a method, you can't exactly predeclare it, so it expects a body
			if method && lexer:test( Symbol, ";" ) source:error "expected function body after method";
			// if the parameter names weren't given, you can't use them, so it won't let you define a body
			if !parameterNamesGiven && !lexer:test( Symbol, ";" ) source:error "expected ';' after partial function declaration";

			let body = !lexer:skip( Symbol, ";" ) && Flux::Parsing::parseFunctionBody( source );
			let value = body && new Flux::Parsing::FunctionExpression( parameters, _type, body, start );
			let function_type = new Flux::Parsing::FunctionType( _type, parameter_types, parameter_nullables );
			let def_name = method && name || Flux::Parsing::resolveDefinitionName( source, name );

			if _template
				source:push( new Flux::Parsing::TemplateDefinition( function_type, _class, def_name, value, isConst, isPublic, isStatic, _template, start ) );
			else
				source:push( new Flux::Parsing::Definition( function_type, _class, def_name, value, isConst, isPublic, isStatic, start ) );

			// create the overloads for the default parameters, each one calling the 'parent' function
			if defaults_started {
				foreach i in 1 .. #defaults {
					Type function_type;
					Expression value;

					Type[] partial_parameter_types = [];
					bool[] partial_parameter_nullables = [];
					FunctionParameter[] partial_parameters = [];
					Expression[] call_parameters = [];

					foreach n in 1 .. #parameter_types - i { // add parameters up to the default for the overload currently being created
						partial_parameter_types[n] = parameter_types[n];
						partial_parameter_nullables[n] = parameter_nullables[n];
						partial_parameters[n] = parameters[n];
						call_parameters[n] = new Flux::Parsing::ReferenceExpression( parameters[n].name, parameters[n].position );
					}

					// loop this to include *all* the default parameters past #defaults-i+1?
					call_parameters[#call_parameters + 1] = defaults[#defaults - i + 1];

					let function_ref = new Flux::Parsing::ReferenceExpression( def_name, start ); // reference to main function
					let function_call = new Flux::Parsing::FunctionCall( function_ref, call_parameters ); // calling the main function
					let body = new Flux::Parsing::Block( [new Flux::Parsing::ReturnStatement( function_call )], start ); // block containing return of above
					let function_type = new Flux::Parsing::FunctionType( _type, partial_parameter_types, partial_parameter_nullables ); // type of overload
					let value = new Flux::Parsing::FunctionExpression( partial_parameters, _type, body, start ); // the function value containing the call to main function

					if _template
						source:push( new Flux::Parsing::TemplateDefinition( function_type, _class, def_name, value, isConst, isPublic, isStatic, _template, start ) ); // push the overload
					else
						source:push( new Flux::Parsing::Definition( function_type, _class, def_name, value, isConst, isPublic, isStatic, start ) ); // push the overload
				}
			}

			return true;
		}
		else if _template
			source:error "expected '(' for function parameters after template";
		else if name:find "^setter " || name:find "^getter "
			source:error( "expected '(' for function parameters after " `concat` name:sub( 1, 1 ) `concat` "etter name" );
		else if name:find "[^%w_:]"
			source:error "expected '(' for function parameters after operator name";
		else if source.context.isClass && name == classname
			source:error "expected '(' for function parameters after constructor name";
		else if method
			source:error "expected '(' for function parameters after method name";
		else if _type.type == Flux::Parsing::ASTNodeType.Typename && _type.name == "void"
			source:error "expected '(' for function parameters after void return type";
		else {
			value = lexer:skip(Symbol, "=") && (Flux::Parsing::Expression:parse( source ) || source:error "expected definition after '='");
			source:push( new Flux::Parsing::Definition( _type, null, Flux::Parsing::resolveDefinitionName( source, name ), value, isConst, isPublic, isStatic, start ) );
		}

		name = null;
		_class = null;
		method = null;
	}
	while lexer:skip( Symbol, "," );

	if !Flux::Parsing::parseSemicolon( lexer )
		source:error "expected ';' after definition(s)";

	return true;
}

string Definition:serialize() {
	return (self.isConst && "const " || "")
		`concat` self._type:serialize() `concat` " " 
		`concat` (self._class && self._class:serialize() `concat` ":" || "")
		`concat` self.name
		`concat` (self.value && " = " `concat` self.value:serialize() || "")
		`concat` ";";
}
