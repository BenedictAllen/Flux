
namespace Flux::Parsing;

bool Definition:parse(Source source) {
	let lexer = source.lexer;
	let start = lexer:mark();
	let isConst = lexer:skip( Keyword, "const" );

	Type _type;

	try {
		_type = Flux::Parsing::Type:parse( source );
	}
	catch ParserException e {}

	if !_type && lexer:test(Keyword, "void")
		_type = new Flux::Parsing::Typename("void", lexer:next().value);


	if !_type || !lexer:test(Identifier) && !lexer:test(Keyword, "operator") {
		lexer:jump( start );
		if isConst {
			lexer:next();
			source:error "expected definition after 'const'";
		}
		return false;
	}

	repeat {
		Position start;
		string name;
		string method;
		Expression value;

		start = lexer:get().position;
		name = Flux::Parsing::parseMethodName(source);
		
		if name:find "[^%w_]" && lexer:test( Symbol, ":" )
			source:error "unexpected ':' after operator name";

		method = lexer:skip( Symbol, ":" ) && Flux::Parsing::parseMethodName(source);

		if lexer:skip( Symbol, "(" ) { // function definition
			FunctionParameter[] parameters = [];
			Type[] parameter_types = [];
			bool[] parameter_nullables = [];
			FunctionParameter parameter;
			Type _class;

			if !lexer:skip( Symbol, ")" ) {
				repeat {
					parameter = Flux::Parsing::FunctionParameter:parse(source, parameter);
					parameters[#parameters + 1] = parameter;
					parameter_types[#parameter_types + 1] = parameter._type;
					parameter_nullables[#parameter_nullables + 1] = parameter.nullable;
				}
				while lexer:skip( Symbol, "," );

				if !lexer:skip( Symbol, ")" )
					source:error "expected ')' to close function parameters";
			}

			if method && lexer:test( Symbol, ";" ) source:error "expected function body after method";

			let body = !lexer:skip( Symbol, ";" ) && Flux::Parsing::parseFunctionBody( source );
			let value = body && new Flux::Parsing::FunctionExpression( parameters, _type, body, start );

			if method {
				_class = new Flux::Parsing::Typename( name, start );
				name = method;
			}

			let function_type = new Flux::Parsing::FunctionType(_type, parameter_types, parameter_nullables);
			source:push( new Flux::Parsing::Definition( function_type, _class, name, value, isConst, start ) );

			return true;
		}
		else if name:find "[^%w_]"
			source:error "expected '(' for function parameters after operator name";
		else if _type.type == Flux::Parsing::ASTNodeType.Typename && _type.name == "void"
			source:error "expected '(' for function parameters after void return type";
		else if method
			source:error "expected '(' for function parameters after method name";
		else {
			value = lexer:skip(Symbol, "=") && (Flux::Parsing::Expression:parse( source ) || source:error "expected definition after '='");
			source:push( new Flux::Parsing::Definition( _type, null, name, value, isConst, start ) );
		}
	}
	while lexer:skip( Symbol, "," );

	if !lexer:skip( Symbol, ";" )
		source:error "expected ';' after definition(s)";

	return true;
}

string Definition:serialize() {
	return (self.isConst && "const " || "")
		`concat` self._type:serialize() `concat` " " 
		`concat` (self._class && self._class:serialize() `concat` ":" || "")
		`concat` self.name
		`concat` (self.value && " = " `concat` self.value:serialize() || "")
		`concat` ";";
}
