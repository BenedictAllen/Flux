
import FunctionParameter;

namespace Flux::Parsing;

class Definition extends ASTNode {
	ASTNodeType type = Flux::Parsing::ASTNodeType.Definition;
	Type _type;
	string name;
	Expression value;
	bool isConst;
	
	Definition(Type _type, string name, null Expression value, bool isConst, Position position) {
		self._type = _type;
		self.name = name;
		self.value = value;
		self.isConst = isConst;
		self.position = position;
	}
}

bool Definition:parse(Source source) {
	let lexer = source.lexer;
	let start = lexer:mark();
	let isConst = lexer:skip( Keyword, "const" );

	Type _type;

	try {
		_type = Flux::Parsing::Type:parse( source );
	}
	catch ParserException e {}

	if !_type && lexer:test(Keyword, "void")
		_type = new Flux::Parsing::Typename("void", lexer:next().value);


	if !_type || !lexer:test(Identifier) && !lexer:test(Keyword, "operator") {
		lexer:jump( start );
		if isConst {
			lexer:next();
			source:error "expected definition after 'const'";
		}
		return false;
	}

	repeat {
		Position start;
		string name;
		string method;
		Expression value;

		start = lexer:get().position;
		name = Flux::Parsing::parseMethodName(source);
		method = lexer:skip( Symbol, ":" ) && Flux::Parsing::parseMethodName(source);

		if lexer:skip( Symbol, "(" ) { // function definition
			FunctionParameter[] parameters = [];
			Type[] parameter_types = [];
			bool[] parameter_nullables = [];
			FunctionParameter parameter;

			if !lexer:skip( Symbol, ")" ) {
				repeat {
					parameter = Flux::Parsing::FunctionParameter:parse(source, parameter);
					parameters[#parameters + 1] = parameter;
					parameter_types[#parameter_types + 1] = parameter._type;
					parameter_nullables[#parameter_nullables + 1] = parameter.nullable;
				}
				while lexer:skip( Symbol, "," );

				if !lexer:skip( Symbol, ")" )
					source:error "expected ')' to close function parameters";
			}

			let body = !lexer:skip( Symbol, ";" ) && Flux::Parsing::parseFunctionBody( source );
			let value = body && new Flux::Parsing::FunctionExpression( parameters, _type, body, start );

			if method {
				let nameAndIndex = new Flux::Parsing::DotIndex( new Flux::Parsing::ReferenceExpression( name, start ), method, start );
				source:push( new Flux::Parsing::BinaryExpression( nameAndIndex, value, "=" ) );
			}
			else {
				let function_type = new Flux::Parsing::FunctionType(_type, parameter_types, parameter_nullables);
				source:push( new Flux::Parsing::Definition( function_type, name, value, isConst, start ) );
			}

			return true;
		}
		else if name:find "[^%w_]"
			source:error "expected '(' for function parameters after operator name";
		else if _type.type == Flux::Parsing::ASTNodeType.Typename && _type.name == "void"
			source:error "expected '(' for function parameters after void return type";
		else if method
			source:error "expected '(' for function parameters after method name";
		else {
			value = lexer:skip(Symbol, "=") && (Flux::Parsing::Expression:parse( source ) || source:error "expected definition after '='");
			source:push( new Flux::Parsing::Definition( _type, name, value, isConst, start ) );
		}
	}
	while lexer:skip( Symbol, "," );

	if !lexer:skip( Symbol, ";" )
		source:error "expected ';' after definition(s)";

	return true;
}

string Definition:serialize() {
	return (self.isConst && "const " || "")
		`concat` self._type:serialize()
		`concat` " " `concat` self.name
		`concat` (self.value && " = " `concat` self.value:serialize() || "")
		`concat` ";";
}
