
import language;
import operators.Operators;

namespace Flux::Parsing;

char[] letters = [];

bool parseSemicolon(Lexer lexer);
void expectSemicolon(Source source, null string location);

bool tokenFollowsLast(Lexer lexer);
bool tokenSameLineAsLast(Lexer lexer);

string parseName(Source source);
string parseMethodName(Source source);
string parseInstructionOperand(Lexer lexer);

string resolveDefinitionName(Source source, string name);

string intToName(int n);

Block parseFunctionBody(Source source, bool is_vararg);

string serializeExpression(Expression e);

bool parseSemicolon(Lexer lexer)
	= ((lexer:skip(Symbol, ";") || lexer:test(Symbol, ";", -1)) || lexer:test(Symbol, "}")) && true || false;

void expectSemicolon(Source source, null string location)
	if !Flux::Parsing::parseSemicolon( source.lexer )
		source:error( "expected ';'" `concat` (location && " at " `concat` location || "") );

bool tokenFollowsLast(Lexer lexer)
	= a.position.line == b.position.line && a.position.source == b.position.source && a.position.character + #a.value == b.position.character
	where a = lexer:peek( -1 )
	where b = lexer:get();

bool tokenSameLineAsLast(Lexer lexer)
	= a.position.line == b.position.line && a.position.source == b.position.source
	where a = lexer:peek( -1 )
	where b = lexer:get();

string parseName(Source source) {
	let name = source.lexer:skipValue(Identifier);

	if (name) while source.lexer:skip(Symbol, "::")
		name = name `concat` "::" `concat` (source.lexer:skipValue(Identifier) || source:error "expected name after ':'");

	return name;
}

string parseMethodName(Source source) {
	let lexer = source.lexer;

	if lexer:skip( Keyword, "operator" ) {
		if lexer:test( Symbol, "(" ) { // call operator: can't skip as `bool operator(int)` not `bool operator()(int)`
			return "()";
		}
		else if lexer:skip( Symbol, "[" ) { // index/setindex operator
			if !lexer:skip( Symbol, "]" ) source:error "expected ']' after '['";
			return lexer:skip( Symbol, "=" ) && "[]=" || "[]";
		}
		else {
			string op = Flux::Parsing::parseOperator( lexer );
			return op != "" && op
			    || source:error( "expected operator after 'operator'", symbol && symbol.position );
		}
	}
	else if lexer:skip( Keyword, "setter" )
		return "setter " `concat` (lexer:skipValue( Identifier ) || source:error "expected name after 'setter'");
	else if lexer:skip( Keyword, "getter" )
		return "getter " `concat` (lexer:skipValue( Identifier ) || source:error "expected name after 'getter'");

	return lexer:skipValue( Identifier );
}

string parseInstructionOperand( Lexer lexer ) {
	string s = lexer:skipValue( String ) || lexer:skipValue( Character ) || lexer:skipValue( Float ) || lexer:skipValue( Integer ) || lexer:skipValue( Byte ) || lexer:skipValue( Hexadecimal ) || lexer:skipValue( Binary ) || lexer:skipValue( Boolean ) || lexer:skipValue( Null );
	if s return s;
	s = lexer:skipValue( Identifier );
	if s {
		while (lexer:test( Symbol, "-" ) || lexer:test( Symbol, "." ))
		   && (Flux::Parsing::tokenFollowsLast( lexer ))
		   && (lexer:test( Identifier, null, 1 ))
		   && (lexer:peek(1).position.character == lexer:get().position.character + 1)
			s = s `concat` lexer:next().value `concat` lexer:next().value;
		return s;
	}
}

string intToName( int n ) {
	string s = Flux::Parsing::letters[n % #Flux::Parsing::letters];

	while n > #Flux::Parsing::letters {
		n = math.floor( n / #Flux::Parsing::letters ) - 1;
		s = Flux::Parsing::letters[n % #Flux::Parsing::letters] .. s;
	}

	return s;
}

Block parseFunctionBody(Source source, bool is_vararg) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	Block block;

	source.file:push_context():specialise_function( is_vararg );

	if lexer:skip( Symbol, "=" ) {
		let expr = Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '='";
		Statement[] statements = [];

		while lexer:test( Keyword, "where" ) {
			Position position = lexer:next().position;
			string name = lexer:skipValue( Identifier ) || source:error "expected name after 'where'";
			Expression value;
			Typename _type = Flux::Parsing::types::auto_type( position );

			if lexer:skip( Symbol, "=" )
				value = Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '='";
			else
				source:error "expected '='";

			statements[#statements + 1] = new Flux::Parsing::Definition( _type, null, name, value, true, false, false, position );
		}

		statements[#statements + 1] = new Flux::Parsing::ReturnStatement( expr, position );

		if !Flux::Parsing::parseSemicolon(lexer)
			source:error "expected ';' after function return";

		block = new Flux::Parsing::Block( statements, position );
	}
	else
		block = Flux::Parsing::Block:parse( source );

	source.file:pop_context();

	return block;
}

string serializeExpression(Expression e)
	=  e typeof Flux::Parsing::ConstantExpression && e:serialize()
	|| e typeof Flux::Parsing::ReferenceExpression && e:serialize()
	|| e typeof Flux::Parsing::FunctionCall && e:serialize()
	|| e typeof Flux::Parsing::MethodCall && e:serialize()
	|| e typeof Flux::Parsing::Index && e:serialize()
	|| e typeof Flux::Parsing::DotIndex && e:serialize()
	|| "(" `concat` e:serialize() `concat` ")";

let _ = (function() {
	int n = 0;
	foreach i in string.byte "a" .. string.byte "z"
		Flux::Parsing::letters[n++] = string.char( i );

	foreach i in string.byte "A" .. string.byte "Z"
		Flux::Parsing::letters[n++] = string.char( i );
})();
