
import language;
import operators.Operators;

namespace Flux::Parsing;

char[] letters = [];

bool parseSemicolon(Lexer lexer);
void expectSemicolon(Source source, null string location);

bool tokenFollowsLast(Lexer lexer);
bool tokenSameLineAsLast(Lexer lexer);

string parseName(Source source);
string parseMethodName(Source source);
string parseInstructionOperand(Lexer lexer);

string resolveDefinitionName(Source source, string name);

string intToName(int n);

Block parseFunctionBody(Source source, bool is_vararg);

string serializeExpression(Expression e);

bool parseSemicolon(Lexer lexer)
	= ((lexer:skip(Symbol, ";") || lexer:test(Symbol, ";", -1)) || lexer:test(Symbol, "}")) && true || false;

void expectSemicolon(Source source, null string location)
	if !Flux::Parsing::parseSemicolon( source.lexer ) {
		Position position = source.lexer:get().position;
		string src = position.source;
		int line = position.line;
		string strline = position.strline:gsub( "\t", " " );
		string char_pointer = (" "):rep( position.character - 1 ) `concat` "^";

		if !strline:sub( 1, position.character - 1 ):find "%S" && source.lexer:peek( -1 ) {
			position = source.lexer:peek( -1 ).position;

			src = position.source;
			line = position.line;
			strline = position.strline:gsub( "\t", " " );
			char_pointer = (" "):rep( #strline ) `concat` "^";
		}

		throw new ParserException(
			src `concat` "[" `concat` line
			`concat` "]: expected ';'" `concat` (location && " at " `concat` location || "")
			`concat` "\n\t" `concat` strline `concat` "\n\t" `concat` char_pointer
		);
	}

bool tokenFollowsLast(Lexer lexer)
	= a.position.line == b.position.line && a.position.source == b.position.source && a.position.character + #a.value == b.position.character
	where a = lexer:peek( -1 )
	where b = lexer:get();

bool tokenSameLineAsLast(Lexer lexer)
	= a.position.line == b.position.line && a.position.source == b.position.source
	where a = lexer:peek( -1 )
	where b = lexer:get();

string parseName(Source source) {
	string name = source.lexer:skipValue( Identifier );

	if name
		while source.lexer:skip(Symbol, "::")
			name = name `concat` "::" `concat` (source.lexer:skipValue(Identifier) || source:error "expected name after ':'");

	return name;
}

string parseMethodName(Source source) {
	let lexer = source.lexer;

	if lexer:skip( Keyword, "operator" ) {
		if lexer:test( Symbol, "(" ) { // call operator: can't skip as `bool operator(int)` not `bool operator()(int)`
			return "()";
		}
		else if lexer:skip( Symbol, "[" ) { // index/setindex operator
			if !lexer:skip( Symbol, "]" ) source:error "expected ']' after '['";
			return lexer:skip( Symbol, "=" ) && "[]=" || "[]";
		}
		else {
			Token symbol = source.file.lexer:skip( Symbol );

			if symbol
				if Flux::Parsing::Operator::operators[symbol.value] {
					string operator_s = symbol.value;

					if operator_s == ">" && Flux::Parsing::tokenFollowsLast( source.lexer ) && source.lexer:skip( Symbol, ">" )
						operator_s = ">>";

					if (operator_s == ">" || operator_s == ">>") && Flux::Parsing::tokenFollowsLast( source.lexer ) && source.lexer:skip( Symbol, "=" )
						operator_s = operator_s == ">" && ">=" || ">>=";

					return operator_s;
				}
				else
				    source:error( "expected operator after 'operator'", symbol.position );
			else
			    source:error( "expected operator after 'operator'" );
		}
	}
	else if lexer:skip( Keyword, "setter" )
		return "setter " `concat` (lexer:skipValue( Identifier ) || source:error "expected name after 'setter'");
	else if lexer:skip( Keyword, "getter" )
		return "getter " `concat` (lexer:skipValue( Identifier ) || source:error "expected name after 'getter'");

	return lexer:skipValue( Identifier );
}

string parseInstructionOperand( Lexer lexer ) {
	string s = lexer:skipValue( String ) || lexer:skipValue( Character ) || lexer:skipValue( Float ) || lexer:skipValue( Integer ) || lexer:skipValue( Byte ) || lexer:skipValue( Hexadecimal ) || lexer:skipValue( Binary ) || lexer:skipValue( Boolean ) || lexer:skipValue( Null );
	if s return s;
	s = lexer:skipValue( Identifier );
	if s {
		while (lexer:test( Symbol, "-" ) || lexer:test( Symbol, "." ))
		   && (Flux::Parsing::tokenFollowsLast( lexer ))
		   && (lexer:test( Identifier, null, 1 ))
		   && (lexer:peek(1).position.character == lexer:get().position.character + 1)
			s = s `concat` lexer:next().value `concat` lexer:next().value;
		return s;
	}
}

string resolveDefinitionName(Source source, string name) {
	if source.file.context:get_flag "is_root_level"
		if source.file.context.namespace_name != ""
			return source.file.context.namespace_name `concat` "::" `concat` name;
	return name;
}

string intToName( int n ) {
	string s = Flux::Parsing::letters[n % #Flux::Parsing::letters];

	while n > #Flux::Parsing::letters {
		n = math.floor( n / #Flux::Parsing::letters ) - 1;
		s = Flux::Parsing::letters[n % #Flux::Parsing::letters] .. s;
	}

	return s;
}

Block parseFunctionBody(Source source, bool is_vararg) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	Block block;

	source.file:push_context():specialise_function( is_vararg );

	if lexer:skip( Symbol, "=" ) {
		let expr = Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '='";
		Statement[] statements = [];

		while lexer:test( Keyword, "where" ) {
			Position position = lexer:next().position;
			string name = lexer:skipValue( Identifier ) || source:error "expected name after 'where'";
			Expression value;

			new Flux::Parsing::TemplatedName _type( "@auto@", [], position );

			if lexer:skip( Symbol, "=" )
				value = Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '='";
			else
				source:error "expected '='";

			statements[#statements + 1] = new Flux::Parsing::Declaration( _type, name, position, true, true, null, value, null );
		}

		statements[#statements + 1] = new Flux::Parsing::ReturnStatement( expr, position );

		if !Flux::Parsing::parseSemicolon(lexer)
			source:error "expected ';' after function return";

		block = new Flux::Parsing::Block( false, position, statements );
	}
	else
		block = Flux::Parsing::Block:parse( source );

	source.file:pop_context();

	return block;
}

string serializeExpression(Expression e)
	=  e typeof Flux::Parsing::ConstantExpression && e:serialize()
	|| e typeof Flux::Parsing::ReferenceExpression && e:serialize()
	|| e typeof Flux::Parsing::FunctionCall && e:serialize()
	|| e typeof Flux::Parsing::MethodCall && e:serialize()
	|| e typeof Flux::Parsing::Index && e:serialize()
	|| e typeof Flux::Parsing::DotIndex && e:serialize()
	|| "(" `concat` e:serialize() `concat` ")";

let _ = (function() {
	int n = 0;
	foreach i in string.byte "a" .. string.byte "z"
		Flux::Parsing::letters[n++] = string.char( i );

	foreach i in string.byte "A" .. string.byte "Z"
		Flux::Parsing::letters[n++] = string.char( i );
})();
