
namespace Flux::Parsing;

Context Source:pushContext() {
	let context = new Flux::Parsing::Context(self.context);

	self.contexts[#self.contexts + 1] = context;
	self.context = context;

	return context;
}

Context Source:popContext() {
	self.contexts[#self.contexts] = null;
	self.context = self.contexts[#self.contexts];

	return self.context;
}

Context Source:pushRootContext()
	= self:pushContext():specialiseRoot();

Context Source:pushNamespaceContext(string name)
	= self:pushContext():specialiseNamespace(name);

Context Source:pushClassContext(string name)
	= self:pushContext():specialiseClass(name);

Context Source:pushClassnameContext()
	= self:pushContext():specialiseClassname();

Context Source:pushInterfaceContext(string name)
	= self:pushContext():specialiseInterface(name);

Context Source:pushFunctionContext(bool isVararg)
	= self:pushContext():specialiseFunction(isVararg);

Context Source:pushLoopContext()
	= self:pushContext():specialiseLoop();

Block Source:pushBlock() {
	ASTNode[] block = [];

	self.blocks[#self.blocks + 1] = block;
	self.block = block;

	return block;
}

Block Source:popBlock() {
	let block = self.blocks[#self.blocks];

	self.blocks[#self.blocks] = null;
	self.block = self.blocks[#self.blocks];

	return block;
}

void Source:push(ASTNode node) {
	self.block[#self.block + 1] = node;
}

void Source:importFile(string filename) {

}
void Source:parseFileContent(string content, null string source = "string") {
	let old_lexer = self.lexer;
	let lexer = new Flux::Parsing::Lexer(content, source);

	self.lexer = lexer;
	
	while !lexer:isEOF()
		if lexer:skip(Keyword, "import")
			ImportStatement:parse(self);
		else
			Statement:parse(self);

	self.lexer = old_lexer;
}

void Source:error(string err, null Position position = self.lexer:get().position)
	= throw new ParserException(src `concat` "[" `concat` line `concat` "]: " `concat` err `concat` "\n\t"
		`concat` strline `concat` "\n\t"
		`concat` char_pointer)
	where src = position.source
	where line = position.line
	where strline = position.strline:gsub( "\t", " " )
	where char_pointer = (" "):rep( position.character - 1 ) `concat` "^";
