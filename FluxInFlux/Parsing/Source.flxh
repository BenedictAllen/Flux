
import Lexer;
import Context;
import Block;
import statements.Statement;
import expressions.Expression;
import definitions.Definition;
import types.Type;

namespace Flux::Parsing;

const string FLUX_INCLUDE_PATH = "";

class Source {
	string include_path;
	string[] current_include_path;
	bool{string} imported;
	string[] import_queue;
	ASTNode[] statements;
	ASTNode[][] blocks;
	Context[] contexts;

	Lexer lexer;
	Context context;
	ASTNode[] block;

	Source(null string include_path = "") {
		self.include_path = Flux::Parsing::FLUX_INCLUDE_PATH `concat` include_path;
		self.current_include_path = [];
		self.imported = {};
		self.statements = [];
		self.block = self.statements;
		self.blocks = [self.block];
		self.contexts = [];
		self.import_queue = [];
	}

	Context pushContext();
	Context popContext();
	Context pushRootContext();
	Context pushNamespaceContext(string name);
	Context pushClassContext(string name);
	Context pushInterfaceContext(string name);
	Context pushFunctionContext(bool isVararg);
	Context pushLoopContext();

	Block pushBlock();
	Block popBlock();

	void push(ASTNode t);

	void importFile(string name);
	void parseFileContent(string content, null string source = "string");

	void error(string err);
}
