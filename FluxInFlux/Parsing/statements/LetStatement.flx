
import TemplatedName;
import types;
import expressions.AutoCast;

namespace Flux::Parsing;

class LetStatement extends Flux::Parsing::Statement {
	TemplatedName name;
	TemplatedName type;
	Block block;

	LetStatement(TemplatedName name, type, Block block, Position pos) {
		self.name = name;
		self.type = type;
		self.block = block;
		self.position = pos;
	}
}

bool LetStatement:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if !lexer:skip( Keyword, "let" )
		return false;

	if lexer:skip( Keyword, "typeof" ) {
		TemplatedName name = lexer:test( Identifier ) && Flux::Parsing::TemplatedName:parse( source )
		           || source:error "expected name after 'typeof'";

		if !lexer:skip( Symbol, "=" )
			source:error "expected '=' after name";

		TemplatedName type = Flux::Parsing::types::parse( source );

		if !lexer:skip( Keyword, "in" )
			source:error "expected 'in' after type";

		Block block = Flux::Parsing::Block:parse( source );

		source.file:push( new Flux::Parsing::LetStatement(
			name, type, block, position
		) );

		return true;
	}

	bool is_public = source.file.context.is_global_public;

	if lexer:skip( Keyword, "public" ) {
		if !source.file.context:get_flag "is_root_level"
			source:error( "cannot declare function-level definition as public", lexer:peek( -1 ).position );

		is_public = true;
	}
	else if lexer:skip( Keyword, "private" ) {
		if !source.file.context:get_flag "is_root_level"
			source:error( "cannot declare function-level definition as private", lexer:peek( -1 ).position );

		is_public = false;
	}

	bool is_const = lexer:skip( Keyword, "const" );
	ASTNode[] declarations = [];

	repeat {
		Position position = lexer:get().position;
		string name1 = Flux::Parsing::parseName( source );
		TemplatedName cast1 = name1 && (lexer:skip( Symbol, "->" ) && Flux::Parsing::types::parse( source ) || Flux::Parsing::types::auto_type( position ));
		Position backtick_pos = lexer:get().position;
		string backtick = lexer:skipValue( Backtick );
		string name2 = backtick && Flux::Parsing::parseName( source ) || !name1 && source:error "expected name";
		TemplatedName cast2 = name2 && (lexer:skip( Symbol, "->" ) && Flux::Parsing::types::parse( source ) || Flux::Parsing::types::auto_type( lexer:peek(-1).position ));
		FunctionParameter[] parameters;
		Expression expr;
		bool is_vararg = false;

		if backtick {
			parameters = [];

			if name1 {
				parameters[1] = new Flux::Parsing::FunctionParameter( cast1, name1, false );
				if name2
					parameters[2] = new Flux::Parsing::FunctionParameter( cast2, name2, false );
			}
			else if name2
				parameters[1] = new Flux::Parsing::FunctionParameter( cast2, name2, false );
			else
				source:error( "expected operand name after '`" `concat` "`'" );

			cast1 = Flux::Parsing::types::auto_type( cast1.position );
			name1 = backtick;
		}
		else if lexer:skip( Symbol, "(" ) {
			parameters = [];

			if !lexer:skip( Symbol, ")" ) {
				repeat {
					let position = lexer:get().position;
					let name = lexer:skipValue( Identifier )
					        || lexer:skipValue( Symbol, "..." )
							|| source:error "expected parameter name";
					let type = lexer:skip( Symbol, "->" ) && Flux::Parsing::types::parse( source ) || Flux::Parsing::types::auto_type( position );

					parameters[#parameters + 1] = new Flux::Parsing::FunctionParameter( type, name, false );

					if name == "..." {
						if lexer:test( Symbol, "," )
							source:error( "unexpected ',' after vararg (...) parameter" );
						is_vararg = true;
					}
				}
				while lexer:skip( Symbol, "," );

				if !lexer:skip( Symbol, ")" )
					source:error "expected ')'";
			}
		}

		if !lexer:skip( Symbol, "=" )
			source:error "expected '='";

		if parameters
			source.file:push_context():specialise_function( is_vararg );

		expr = Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '='";

		if parameters
			source.file:pop_context();

		if parameters {
			expr = new Flux::Parsing::FunctionExpression(
				parameters,
				cast1,
				new Flux::Parsing::Block( false, position, [new Flux::Parsing::ReturnStatement( expr )] ),
				position
			);
			cast1 = Flux::Parsing::types::auto_type( position );
		}
		else {
			expr = new Flux::Parsing::AutoCast( expr, cast1 );
		}

		declarations[#declarations + 1] = new Flux::Parsing::Declaration(
			cast1,
			Flux::Parsing::resolveDefinitionName( source, name1 ),
			position,
			is_const, is_public,
			null,
			expr,
			null
		);

		if parameters break;
	}
	while lexer:skip( Symbol, "," );

	if source.file.lexer:skip( Keyword, "in" ) {
		source.file:push_context():specialise_block();
		Block block = Flux::Parsing::Block:parse( source );
		source.file:pop_context();

		for (int i = #declarations, i > 0, i--)
			block:push( declarations[i], 1 );

		source.file:push( new Flux::Parsing::DoStatement( block, position ) );
	}
	else {
		Flux::Parsing::expectSemicolon( source, "end of let statement" );

		foreach decl in declarations
			source.file:push( decl );
	}

	return true;
}

string LetStatement:serialize()
	= "let typeof "
	`concat` self.name:serialize() `concat` " = "
	`concat` self.type:serialize() `concat` " in "
	`concat` self.block:serialize();
