
/* TODO

	int x = 1;
	let x = 5 in {
		print( x + 1 ); // 6
	}
	print( x + 1 ); // 2

	new UIElement button;
	let typeof button = UIButton in {
		print( button.text ); // all good
	}
	print( button.text ); // UIElement has no member 'text'
*/

import TemplatedName;
import types;

namespace Flux::Parsing;

class LetStatement extends Flux::Parsing::Statement {}
	// Note, this won't exist in the AST as it uses normal definitions

bool LetStatement:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if !lexer:skip( Keyword, "let" )
		return false;

	bool is_const = lexer:skip( Keyword, "const" ) && true || false;

	repeat {
		Position position = lexer:get().position;
		string name1 = Flux::Parsing::parseName( source );
		TemplatedName cast1 = name1 && (lexer:skip( Symbol, "->" ) && Flux::Parsing::types::parse( source ) || Flux::Parsing::types::auto_type( position ));
		Position backtick_pos = lexer:get().position;
		string backtick = lexer:skipValue( Backtick );
		string name2 = backtick && Flux::Parsing::parseName( source ) || !name1 && source:error "expected name";
		TemplatedName cast2 = name2 && (lexer:skip( Symbol, "->" ) && Flux::Parsing::types::parse( source ) || Flux::Parsing::types::auto_type( lexer:peek(-1).position ));
		FunctionParameter[] parameters;
		Expression expr;

		if backtick {
			parameters = [];

			if name1 {
				parameters[1] = new Flux::Parsing::FunctionParameter( cast1, name1, false );
				if name2
					parameters[2] = new Flux::Parsing::FunctionParameter( cast2, name2, false );
			}
			else if name2
				parameters[1] = new Flux::Parsing::FunctionParameter( cast2, name2, false );
			else
				source:error( "expected operand name after '`" `concat` "`'" );

			name1 = backtick;
		}
		else if lexer:skip( Symbol, "(" ) {
			parameters = [];

			if !lexer:skip( Symbol, ")" ) {
				repeat {
					let position = lexer:get().position;
					let name = lexer:skipValue( Identifier ) || source:error "expected parameter name";
					let type = lexer:skip( Symbol, "->" ) && Flux::Parsing::types::parse( source ) || Flux::Parsing::types::auto_type( position );

					parameters[#parameters + 1] = new Flux::Parsing::FunctionParameter( type, name, false );
				}
				while lexer:skip( Symbol, "," );

				if !lexer:skip( Symbol, ")" )
					source:error "expected ')'";
			}
		}

		if !lexer:skip( Symbol, "=" )
			source:error "expected '='";

		expr = Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '='";

		if parameters {
			expr = new Flux::Parsing::FunctionExpression(
				parameters,
				Flux::Parsing::types::auto_type( position ),
				new Flux::Parsing::Block( [new Flux::Parsing::ReturnStatement( expr )], position ),
				position
			);
			cast1 = Flux::Parsing::types::auto_type( position );
		}
		else {
			expr = new Flux::Parsing::Cast( expr, cast1 );
		}

		source.file:push( new Flux::Parsing::Declaration(
			cast1,
			Flux::Parsing::resolveDefinitionName( source, name1 ),
			position,
			is_const, false, false,
			null,
			expr
		) );

		if parameters break;
	}
	while lexer:skip( Symbol, "," );

	Flux::Parsing::expectSemicolon( source, "let statement" );

	return true;
}

// no need to define its serialize() as it's never added to the AST
