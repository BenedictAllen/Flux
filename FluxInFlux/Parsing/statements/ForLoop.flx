
namespace Flux::Parsing;

ASTNode ForLoop:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if !lexer:skip( Keyword, "for" ) return;

	let openbracket = lexer:skip( Symbol, "(" ) && true || false;

	Type type;
	string name;
	Expression value;
	Expression condition;
	Expression increment;
	
	type = Flux::Parsing::Type:parse( source );
	name = lexer:skipValue( Identifier ) || source:error "expected name after type";
	value = lexer:skip( Symbol, "=" ) &&
		(Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '='")
		|| source:error "expected '='";

	if !Flux::Parsing::parseSemicolon(lexer) && !lexer:skip( Symbol, "," ) source:error "expected ';'";
	
	condition = Flux::Parsing::Expression:parse( source ) || source:error "expected expression";

	if !Flux::Parsing::parseSemicolon(lexer) && !lexer:skip( Symbol, "," ) source:error "expected ';'";

	increment = Flux::Parsing::Expression:parse( source ) || source:error "expected expression";

	if openbracket && !lexer:skip( Symbol, ")" ) source:error "expected ')'";

	source:pushLoopContext();
	let block = Flux::Parsing::Block:parse( source );
	source:popContext();

	block[#block + 1] = increment;

	let doblock = new Flux::Parsing::Block( [
		new Flux::Parsing::Definition( type, null, name, value, false, false, false ),
		new Flux::Parsing::WhileLoop( condition, block )
	], position );

	return new Flux::Parsing::DoStatement( doblock, position );
}

// no need for serialize() as it's never added to the AST
