
namespace Flux::Parsing;

class ForLoop extends Flux::Parsing::Statement {}
	// Note, this won't exist in the AST as it creates a while loop

bool ForLoop:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if !lexer:skip( Keyword, "for" )
		return false;

	let openbracket = lexer:skip( Symbol, "(" ) && true || false;

	Type type;
	string name;
	Expression value;
	Expression condition;
	Expression increment;

	type = Flux::Parsing::Type:parse( source );
	name = lexer:skipValue( Identifier ) || source:error "expected name after type";
	value = lexer:skip( Symbol, "=" )
		&& (Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '='")
		|| source:error "expected '='";

	Flux::Parsing::expectSemicolon( source, "for loop initial value" );
	condition = Flux::Parsing::Expression:parse( source ) || source:error "expected expression";
	Flux::Parsing::expectSemicolon( source, "for loop test expression" );
	increment = Flux::Parsing::Expression:parse( source ) || source:error "expected expression";

	if openbracket && !lexer:skip( Symbol, ")" )
		source:error "expected ')'";

	source.file:push_context():specialise_loop();
	let block = Flux::Parsing::Block:parse( source );
	source.file:pop_context();

	block[#block + 1] = increment;

	let doblock = new Flux::Parsing::Block( [
		new Flux::Parsing::Definition( type, null, name, value, false, false, false ),
		new Flux::Parsing::WhileLoop( condition, block )
	], position );

	source.file:push( Flux::Parsing::DoStatement( doblock, position ) );

	return true;
}

// no need for serialize() as it's never added to the AST
