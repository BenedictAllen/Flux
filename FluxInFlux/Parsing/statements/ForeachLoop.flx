
namespace Flux::Parsing;

class ForeachLoop extends Flux::Parsing::Statement {
	string name1, name2;
	Expression expression;
	Block block;

	ForeachLoop(sstring name1, name2, Expression expression, Block block, null Position position = expression.position) {
		self.name1 = name1;
		self.name2 = name2;
		self.expression = expression;
		self.block = block;
		self.position = position;
	}
}

bool ForeachLoop:parse( Source source ) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if !lexer:skip( Keyword, "foreach" )
		return false;

	let openbracket = lexer:skip( Symbol, "(" ) && true || false;
	let name1 = lexer:skipValue( Identifier ) || source:error "expected name after 'foreach'";
	let name2 = lexer:skip( Symbol, "," ) && (lexer:skipValue( Identifier ) || source:error "expected name after ','");
	let expr = lexer:skip( Keyword, "in" ) && (Flux::Parsing::Expression:parse( source ) || source:error "expected expression after 'in'") || source:error "expected 'in' after name";

	if openbracket && !lexer:skip( Symbol, ")" )
		source:error "expected ')'";

	source:pushLoopContext();
	let block = Flux::Parsing::Block:parse( source );
	source:popContext();

	if !name2 {
		let temp = name1;
		name1 = name2;
		name2 = temp;
	}

	source:push( new Flux::Parsing::ForeachLoop(name1, name2, expr, block, position) );

	return true;
}

string ForeachLoop:serialize()
	= "foreach "
		`concat` (self.name1 && self.name1 `concat` ", " || "") `concat` self.name2
		`concat` " in " `concat` self.expression:serialize()
		`concat` " " `concat` self.block:serialize();
