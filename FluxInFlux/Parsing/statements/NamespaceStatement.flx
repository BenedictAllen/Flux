
namespace Flux::Parsing;

class NamespaceStatement extends Flux::Parsing::Statement {
	string name;
	Block block;

	NamespaceStatement(string name, Block block, Position position) {
		self.name = name;
		self.block = block;
		self.position = position;
	}
}

bool NamespaceStatement:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if lexer:test( Keyword, "namespace" ) && !source.file.context:get_flag "is_root_level"
		source:error "invalid location for 'namespace'";

	if !lexer:skip( Keyword, "namespace" )
		return false;

	string name = Flux::Parsing::parseName( source ) || source:error "expected name after 'namespace'";
	string[] segments = [];

	do {
		int i = 1;
		int s = name:find "::";

		while s {
			segments[#segments + 1] = name:sub( i, s - 1 );
			i = s + 2;
			s = name:find( "::", i );
		}

		segments[#segments + 1] = name:sub( i );
	}

	source.file:push_context():specialise_namespace( name );
	source.file:push_block( lexer:get().position, false );

	if lexer:skip( Symbol, "{" ) {
		while !lexer:skip( Symbol, "}" ) {
			if lexer:isEOF() source:error "expected '}' to block";

			Flux::Parsing::Statement:parse(source);
		}
	}
	else if lexer:skip( Symbol, ";" )
		while !lexer:isEOF()
			Flux::Parsing::Statement:parse(source);
	else
		source:error "expected '{' after namespace name";

	Block block = source.file:pop_block();

	for (int i = #segments; i > 1; i--) {
		block = new Flux::Parsing::Block( false, position, [
			new Flux::Parsing::NamespaceStatement( segments[i], block, position )
		] );
	}

	source.file:push( new Flux::Parsing::NamespaceStatement( segments[1], block, position ) );

	return true;
}

string NamespaceStatement:serialize()
	= "namespace " `concat` self.name `concat` " " `concat` self.block:serialize();
