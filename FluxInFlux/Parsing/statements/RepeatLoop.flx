
namespace Flux::Parsing;

class RepeatLoop extends Flux::Parsing::Statement {
	Expression condition;
	Block block;

	RepeatLoop(Expression condition, Block block, null Position position = condition.position) {
		self.condition = condition;
		self.block = block;
		self.position = position;
	}
}

bool RepeatLoop:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if !lexer:skip( Keyword, "repeat" )
		return false;

	source.file:push_context():specialise_loop();
	let block = Flux::Parsing::Block:parse( source );
	source.file:pop_context();

	Expression condition;
	bool inverted;

	if lexer:skip( Keyword, "until" ) {
		condition = Flux::Parsing::Expression:parse( source ) || source:error "expected condition after 'until'";
		inverted = true;
	}
	else if lexer:skip( Keyword, "while" ) {
		condition = Flux::Parsing::Expression:parse( source ) || source:error "expected condition after 'while'";
		inverted = false;
	}
	else {
		condition = new Flux::Parsing::ConstantExpression( Flux::Parsing::ConstantType.Boolean, "true", position );
		inverted = false;
	}

	if !Flux::Parsing::parseSemicolon(lexer)
		source:error "expected ';' after condition";

	if inverted {
		new Flux::Parsing::Block break_block( false, position );
		new Flux::Parsing::BreakStatement break_statement( position );
		new Flux::Parsing::IfStatement if_break_block( condition, break_block, null, position );
		new Flux::Parsing::ConstantExpression true_constant( Flux::Parsing::ConstantType.Boolean, "true", position );

		break_block:push( break_statement );
		block:push( if_break_block );

		source.file:push( new Flux::Parsing::RepeatLoop( true_constant, block, position ) );
	}
	else {
		source.file:push( new Flux::Parsing::RepeatLoop( condition, block, position ) );
	}

	return true;
}

string RepeatLoop:serialize()
	= "repeat " `concat` self.block:serialize()
	`concat` "\nwhile "
	`concat` Flux::Parsing::serializeExpression( self.condition ) `concat` ";";
