
namespace Flux::Parsing;

bool RepeatLoop:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if !lexer:skip( Keyword, "repeat" )
		return false;

	source:pushLoopContext();
	let block = Flux::Parsing::Block:parse( source );
	source:popContext();

	Expression condition;
	bool inverted;

	if lexer:skip( Keyword, "until" ) {
		condition = Flux::Parsing::Expression:parse( source ) || source:error "expected condition after 'until'";
		inverted = false;
	}

	else if lexer:skip( Keyword, "while" ) {
		condition = Flux::Parsing::Expression:parse( source ) || source:error "expected condition after 'while'";
		inverted = true;
	}
	
	if !Flux::Parsing::parseSemicolon(lexer)
		source:error "expected ';' after condition";

	else
		condition = new Flux::Parsing::ConstantExpression( Flux::Parsing::ConstantType.Boolean, "false" );
		then inverted = false;

	source:push( new Flux::Parsing::RepeatLoop(condition, block, inverted, position) );

	return true;
}

string RepeatLoop:serialize()
	= "repeat " `concat` self.block:serialize() `concat` (self.inverted && "\nwhile " || "\nuntil ") `concat` self.condition:serialize() `concat`;
