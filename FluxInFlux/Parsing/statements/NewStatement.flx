
import TemplatedName;
import types;
import definitions.Declaration;

namespace Flux::Parsing;

class NewStatement {
	static bool parse(Source source);
}

bool NewStatement:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;
	let start = lexer:mark();

	if !lexer:skip( Keyword, "new" )
		return false;

	bool is_public = source.file.context.is_global_public;

	if lexer:skip( Keyword, "public" ) {
		if !source.file.context:get_flag "is_root_level"
			source:error( "cannot declare function-level definition as public", lexer:peek( -1 ).position );

		is_public = true;
	}
	else if lexer:skip( Keyword, "private" ) {
		if !source.file.context:get_flag "is_root_level"
			source:error( "cannot declare function-level definition as private", lexer:peek( -1 ).position );

		is_public = false;
	}

	let is_const = lexer:skip( Keyword, "const" );

	TemplatedName type;
	Expression[] parameters = [];
	int[] list_sizes = [];
	string name;

	source.file:push_context():set_flag "is_parsing_new_type";

	try {
		type = Flux::Parsing::types::parse( source );
	}
	catch ParserException e {
		lexer:jump( start );
		source.file:pop_context();
		return false;
	}

	source.file:pop_context();

	while lexer:skip( Symbol, "[" ) {
		int size = tostring( lexer:skipValue( Integer )
		        || source:error "expected integer after '['" );

		if !lexer:skip( Symbol, "]" )
			source:error "expected ']' after list size";

		list_sizes[#list_sizes + 1] = size;
	}

	name = lexer:skipValue( Identifier );

	// allowing for `new Button();` as an expression statement
	if !name {
		lexer:jump( start );
		return false;
	}

	if lexer:skip( Symbol, "(" ) {
		if !lexer:skip( Symbol, ")" ) {
			repeat {
				parameters[#parameters + 1] = Flux::Parsing::Expression:parse( source );
			}
			while lexer:skip( Symbol, "," );

			if !lexer:skip( Symbol, ")" )
				source:error "expected ')'";
		}
	}

	if !lexer:skip( Symbol, ";" )
		source:error "expected ';' after new statement";

	let def_name = Flux::Parsing::resolveDefinitionName( source, name );
	let value = new Flux::Parsing::NewExpression( type, list_sizes, parameters, position );

	for (int i = 1; i <= #list_sizes; i++)
		type = Flux::Parsing::types::list_type( type.position, type );

	source.file:push( new Flux::Parsing::Declaration( type, def_name, position, is_const, is_public, null, value, null ) );

	return true;
}
