
namespace Flux::Parsing;

bool NewStatement:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;
	let start = lexer:mark();

	if !lexer:skip( Keyword, "new" ) return false;

	Type _type;
	Expression[] parameters = [];
	string name;

	try {
		_type = Flux::Parsing::Type:parse( source );
	}
	catch ParserException e {
		lexer:jump( start );
		return false;
	}

	name = lexer:skipValue( Identifier );

	if !name {
		lexer:jump( start ); 
		return false;
	}

	if lexer:skip( Symbol, "(" ) {
		if !lexer:skip( Symbol, ")" ) {
			repeat {
				parameters[#parameters + 1] = Flux::Parsing::Expression:parse( source );
			}
			while lexer:skip( Symbol, "," );

			if !lexer:skip( Symbol, ")" )
				source:error "expected ')'";
		}
	}

	if !lexer:skip( Symbol, ";" )
		source:error "expected ';' after new statement";

	let def_name = Flux::Parsing::resolveDefinitionName( source, name );
	let value = new Flux::Parsing::NewExpression( _type, parameters, position );

	source:push( new Flux::Parsing::Definition( _type, null, def_name, value, false, position ) );

	return true;
}

// no need to define its serialize() as it's never added to the AST
