
import TemplatedName;
import types;
import definitions.Declaration;

namespace Flux::Parsing;

class NewStatement {
	static bool parse(Source source);
}

bool NewStatement:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;
	let start = lexer:mark();

	if !lexer:skip( Keyword, "new" )
		return false;

	bool is_public = source.file.context.is_global_public;

	if lexer:skip( Keyword, "public" ) {
		if !source.file.context:get_flag "is_root_level"
			source:error( "cannot declare function-level definition as public", lexer:peek( -1 ).position );

		is_public = true;
	}
	else if lexer:skip( Keyword, "private" ) {
		if !source.file.context:get_flag "is_root_level"
			source:error( "cannot declare function-level definition as private", lexer:peek( -1 ).position );

		is_public = false;
	}

	let is_const = lexer:skip( Keyword, "const" );

	TemplatedName _type;
	Expression[] parameters = [];
	string name;

	try {
		_type = Flux::Parsing::types::parse( source );
	}
	catch ParserException e {
		lexer:jump( start );
		return false;
	}

	name = lexer:skipValue( Identifier );

	// allowing for `new Button();` as an expression statement
	if !name {
		lexer:jump( start );
		return false;
	}

	if lexer:skip( Symbol, "(" ) {
		if !lexer:skip( Symbol, ")" ) {
			repeat {
				parameters[#parameters + 1] = Flux::Parsing::Expression:parse( source );
			}
			while lexer:skip( Symbol, "," );

			if !lexer:skip( Symbol, ")" )
				source:error "expected ')'";
		}
	}

	if !lexer:skip( Symbol, ";" )
		source:error "expected ';' after new statement";

	let def_name = Flux::Parsing::resolveDefinitionName( source, name );
	let value = new Flux::Parsing::NewExpression( _type, parameters, position );

	source.file:push( new Flux::Parsing::Declaration( _type, def_name, position, is_const, is_public, false, null, value ) );

	return true;
}
