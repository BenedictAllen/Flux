
import TemplatedName;

namespace Flux::Parsing;

class NewStatement {
	static bool parse(Source source);
}

bool NewStatement:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;
	let start = lexer:mark();

	if !lexer:skip( Keyword, "new" )
		return false;

	let isConst = lexer:skip( Keyword, "const" ) && true || false;

	TemplatedName _type;
	Expression[] parameters = [];
	string name;

	try {
		_type = Flux::Parsing::types:parse( source );
	}
	catch ParserException e {
		lexer:jump( start );
		return false;
	}

	name = lexer:skipValue( Identifier );

	// allowing for `new Button();` as an expression statement
	if !name {
		lexer:jump( start );
		return false;
	}

	if lexer:skip( Symbol, "(" ) {
		if !lexer:skip( Symbol, ")" ) {
			repeat {
				parameters[#parameters + 1] = Flux::Parsing::Expression:parse( source );
			}
			while lexer:skip( Symbol, "," );

			if !lexer:skip( Symbol, ")" )
				source:error "expected ')'";
		}
	}

	if !lexer:skip( Symbol, ";" )
		source:error "expected ';' after new statement";

	let def_name = Flux::Parsing::resolveDefinitionName( source, name );
	let value = new Flux::Parsing::NewExpression( _type, parameters, position );

	source.file:push( new Flux::Parsing::Definition( _type, null, def_name, value, isConst, false, false, position ) );

	return true;
}
