
import expressions.ConstantType;

namespace Flux::Parsing;

class ReturnStatement extends Flux::Parsing::Statement {
	Expression value;

	ReturnStatement(Expression value, null Position position = value.position) {
		self.position = position;
		self.value = value;
	}
}

bool ReturnStatement:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if !source.context.isFunction && lexer:test( Keyword, "return" )
		source:error "cannot return from outside function";

	if !lexer:skip( Keyword, "return" )
		return false;

	let expr = Flux::Parsing::Expression:parse( source ) || new Flux::Parsing::ConstantExpression( Flux::Parsing::ConstantType.Null, "null", position );

	Flux::Parsing::expectSemicolon( source, "return statement" );

	source:push( new Flux::Parsing::ReturnStatement( expr, position ) );

	return true;
}

string ReturnStatement:serialize()
	= "return " `concat` self.value:serialize() `concat` ";";
