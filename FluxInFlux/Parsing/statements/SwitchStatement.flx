
namespace Flux::Parsing;

class SwitchStatement extends Flux::Parsing::Statement {
	Expression expression;
	Expression[][] cases;
	Block[] blocks;
	Block _default;

	SwitchStatement(Expression expression, Expression[][] cases, Block[] blocks, null Block _default, null Position position = expression.position) {
		self.expression = expression;
		self.cases = cases;
		self.blocks = blocks;
		self._default = _default;
		self.position = position;
	}
}

bool SwitchStatement:parse(Source source) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if !lexer:skip( Keyword, "switch" )
		return false;

	let expr = Flux::Parsing::Expression:parse( source ) || source:error "expected expression to switch";

	Expression[][] cases = [];
	Block[] blocks = [];
	Block _default;

	Flux::Parsing::expectSemicolon( source, "switch statement expression" );

	while lexer:skip( Keyword, "case" ) {
		Expression[] this_cases = [];

		repeat
			this_cases[#this_cases + 1] = Flux::Parsing::Expression:parse( source ) || source:error "expected case expression";
		while lexer:skip( Symbol, "," );

		source.file:push_context():specialise_block();
		cases[#cases + 1] = this_cases;
		blocks[#blocks + 1] = Flux::Parsing::Block:parse( source );
		source.file:pop_context();
	}

	if #cases == 0
		source:error "expected at least one case to switch";

	if lexer:skip( Keyword, "default" ) {
		source.file:push_context();
		_default = Flux::Parsing::Block:parse( source );
		source.file:pop_context();
	}

	source.file:push( new Flux::Parsing::SwitchStatement(expr, cases, blocks, _default, position) );

	return true;
}

string SwitchStatement:serialize() {
	string[] c = [];

	foreach i, v in self.cases
		c[i] = "case " `concat` (v `concattenate` ", ") `concat` " " `concat` self.blocks[i]:serialize();

	return "switch " `concat` self.expression:serialize() `concat` ";\n" `concat` table.concat( c, "\n" )
		`concat` (self._default && "\ndefault " `concat` self._default:serialize() || "");
}
