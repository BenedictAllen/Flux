
namespace Flux::Parsing;

Operator::Binary OperatorExpressionStack:pop_operator() {
	self.operator_positions[#self.operator_positions] = null;
	return table.remove( self.operators, #self.operators );
}

Expression OperatorExpressionStack:pop_operand()
 	= table.remove( self.operands, #self.operands );

bool OperatorExpressionStack:get_term(Source source) {
	return Flux::Parsing::BacktickExpression:parse( source );
}

void OperatorExpressionStack:push_operand(ASTNode e) {
	self.operands[#self.operands + 1] = e;
}

void OperatorExpressionStack:push_operator(Operator::Binary op, Position p) {
	Operator::Binary top = self.operators[#self.operators];

	while top {
		if ( top.precedence  > op.precedence )
		|| ( top.precedence == op.precedence )
		&& ( top.symbol     != op.symbol || top.left_assoc ) {
			self:collapse();
		}
		else break;

		top = self.operators[#self.operators];
	}

	self.operators[#self.operators + 1] = op;
	self.operator_positions[#self.operator_positions + 1] = p;
}

bool OperatorExpressionStack:get_first_term(Source source) {
	let expr = self:get_term( source );

	if expr {
		self:push_operand( expr );
		return true;
	}
	return false;
}

bool OperatorExpressionStack:get_next_term(Source source) {
	Token operator_t = source.lexer:test( Symbol );

	if !operator_t
		return false;

	string operator_s = operator_t && operator_t.value;
	Position position = operator_t && operator_t.position;

	if Flux::Parsing::Operator::is_binary( operator_s ) {
		source.lexer:next();

		if operator_s == ">" && Flux::Parsing::tokenFollowsLast( source.lexer ) && source.lexer:skip( Symbol, ">" )
			operator_s = ">>";

		if (operator_s == ">" || operator_s == ">>") && Flux::Parsing::tokenFollowsLast( source.lexer ) && source.lexer:skip( Symbol, "=" )
			operator_s = operator_s == ">" && ">=" || ">>=";

		Operator::Binary op = Flux::Parsing::Operator::get_binary( operator_s );
		ASTNode expr = self:get_term( source );

		if !expr
			source:error( "expected operand after op '" `concat` operator_s `concat` "'" );

		self:push_operator( op, position );
		self:push_operand( expr );

		return true;
	}
	else
		return false;


}


void OperatorExpressionStack:collapse() {
	let op       = self:pop_operator().symbol,
	    rvalue   = self:pop_operand(),
		lvalue   = self:pop_operand(),
		position = table.remove( self.operator_positions, #self.operator_positions );

	self:push_operand(
		new Flux::Parsing::BinaryExpression( lvalue, rvalue, op, position )
	);
}

Expression OperatorExpressionStack:result() {
	while #self.operands > 1
		self:collapse();

	return self.operands[1];
}
