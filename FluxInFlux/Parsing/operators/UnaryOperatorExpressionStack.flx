
namespace Flux::Parsing;

void UnaryOperatorExpressionStack:get_top_left_opcode()
	= self.left_opcode_cache[#self.left_opcode_cache];

void UnaryOperatorExpressionStack:combine_left_operator() {
	string op = table.remove( self.left_operator_cache, #self.left_operator_cache );
	Position pos = table.remove( self.left_operator_positions, #self.left_operator_positions );

	self.left_opcode_cache[#self.left_opcode_cache] = null;

	self.term = new Flux::Parsing::LeftUnaryExpression( self.term, op, pos );
}

// parse and store all left unary operators
void UnaryOperatorExpressionStack:parse_left_unary_operators(Source source) {
	UnaryOpcode opcode = Flux::Parsing::Operator::get_unary_opcode( source );

	while opcode != Flux::Parsing::Operator::UnaryOpcode.None
	   && Flux::Parsing::Operator::is_unary_left_operator( opcode ) {
		string op = source.lexer:get().value;
		Position pos = source.lexer:next().position;

		self.left_operator_cache[#self.left_operator_cache + 1] = op;
		self.left_opcode_cache[#self.left_opcode_cache + 1] = opcode;
		self.left_operator_positions[#self.left_operator_positions + 1] = pos;

		opcode = Flux::Parsing::Operator::get_unary_opcode( source );
	}
}

bool UnaryOperatorExpressionStack:parse_term(Source source) {
	self.term = Flux::Parsing::PrimaryExpression:parse( source );

	if !self.term {
		if #self.left_operator_cache > 0
			source:error( "expected expression after operator "
				`concat` self.left_operator_cache[#self.left_operator_cache] );
		return false;
	}
	return true;
}

void UnaryOperatorExpressionStack:parse_right_unary_operators(Source source) {
	UnaryOpcode opcode = Flux::Parsing::Operator::get_unary_opcode( source );

	while opcode != Flux::Parsing::Operator::UnaryOpcode.None {
		while Flux::Parsing::Operator::get_unary_precedence( self:get_top_left_opcode(), opcode ) {
			self:combine_left_operator();
		}

		ASTNode expr = Flux::Parsing::RightUnaryExpression:parse( source, self.term );

		if expr
			self.term = expr;
		else
			break;

		opcode = Flux::Parsing::Operator::get_unary_opcode( source );
	}
}

ASTNode UnaryOperatorExpressionStack:result() {
	while #self.left_operator_cache > 0
		self:combine_left_operator();

	return self.term;
}
