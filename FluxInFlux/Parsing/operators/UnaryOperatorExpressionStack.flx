
namespace Flux::Parsing;

void UnaryOperatorExpressionStack:get_top_left_opcode()
	= self.left_opcode_cache[#self.left_opcode_cache];

void UnaryOperatorExpressionStack:combine_left_operator() {
	string op = table.remove( self.left_operator_cache, #self.left_operator_cache );
	Position pos = table.remove( self.left_operator_positions, #self.left_operator_positions );

	self.left_opcode_cache[#self.left_opcode_cache] = null;

	self.term = new LeftUnaryExpression( self.value, op, pos );
}

// parse and store all left unary operators
void UnaryOperatorExpressionStack:parse_left_unary_operators(Source source) {
	UnaryOpcode opcode = Flux::Parsing::Operator::get_unary_opcode( source );

	while opcode != Flux::Parsing::Operator::UnaryOpcode.None
	   && Flux::Parsing::Operator::is_unary_left_operator( opcode ) {
		string op = lexer:get().value;
		Position pos = lexer:next().position;

		self.left_operator_cache[#self.left_operator_cache + 1] = op;
		self.left_opcode_cache[#self.left_opcode_cache + 1] = opcode;
		self.left_operator_positions[#self.left_operator_positions + 1] = pos;

		opcode = Flux::Parsing::Operator::get_unary_opcode( source );
	}
}

void UnaryOperatorExpressionStack:parse_term(Source source) {
	self.term = Flux::Parsing::PrimaryExpression:parse( source );
}

void UnaryOperatorExpressionStack:parse_right_unary_operators(Source source) {
	UnaryOpcode opcode = Flux::Parsing::Operator::get_unary_opcode( source );

	while opcode != Flux::Parsing::Operator::UnaryOpcode.None {
		while Flux::Parsing::Operator::get_unary_precedence( self:get_top_left_opcode(), opcode )
			self:combine_left_operator();

		self.term = Flux::Parsing::RightUnaryExpression:parse( source, self.term );
	}
}

ASTNode UnaryOperatorExpressionStack:result() {
	while #self.left_operator_cache > 0
		self:combine_left_operator();

	return self.term;
}
