
namespace Flux::Parsing;

TemplatedType TemplatedType:parse( Source source ) {
	let lexer = source.lexer;
	let start = lexer:mark();
	let position = lexer:get().position;
	let name = Flux::Parsing::parseName( source ) || lexer:skipValue( Keyword, "auto" );

	if name && lexer:skip( Symbol, "<" ) {
		Type[] _template = [];

		repeat
			_template[#_template + 1] = Flux::Parsing::Type:parse( source );
		while lexer:skip( Symbol, "," );

		if !lexer:skip( Symbol, ">" ) source:error "expected '>' after template";

		return new Flux::Parsing::TemplatedType( name, _template, position );
	}
	else
		lexer:jump( start );
		then return;
}

string TemplatedType:serialize() {
	string[] t = [];

	foreach i, v in self._template
		t[i] = v:serialize();

	return self.name `concat` "<" `concat` table.concat( t, ", " ) `concat` ">";
}
