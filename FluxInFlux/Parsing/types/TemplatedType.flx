
namespace Flux::Parsing;

class TemplatedType extends Flux::Parsing::Type {
	ASTNodeType type = Flux::Parsing::ASTNodeType.TemplatedType;
	string name;
	Type[] _template;

	TemplatedType( string name, Type[] _template, Position position ) {
		self.name = name;
		self._template = _template;
		self.position = position;
	}
}

TemplatedType TemplatedType:parse( Source source ) {
	let lexer = source.lexer;
	let start = lexer:mark();
	let position = lexer:get().position;
	let name = Flux::Parsing::parseName( source ) || lexer:skipValue( Keyword, "auto" );

	if name && lexer:skip( Symbol, "<" ) {
		Type[] _template = [];

		repeat
			_template[#_template + 1] = Flux::Parsing::Type:parse( source );
		while lexer:skip( Symbol, "," );

		if !lexer:skip( Symbol, ">" ) source:error "expected '>' after template";

		return new Flux::Parsing::TemplatedType( name, _template, position );
	}
	else
		lexer:jump( start );
		then return;
}

string TemplatedType:serialize() {
	string[] t = [];

	foreach i, v in self._template
		t[i] = v:serialize();

	return self.name `concat` "<" `concat` table.concat( t, ", " ) `concat` ">";
}
