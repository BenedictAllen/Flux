
namespace Flux::Parsing;

string Type:serialize()
	= self.name `concat` (#self.classes == 0 && "" || "<" `concat` (self.classes `concattenate` ", ") `concat` ">");

ASTNode Type:parse( Source source ) {
	let lexer = source.lexer;
	let start = lexer:mark();
	let position = lexer:get().position;

	string name = Flux::Parsing::parseName( source ) || lexer:skipValue( Keyword, "auto" );
	Type[] classes = [];
	Type type;

	if name && lexer:skip( Symbol, "<" ) {
		repeat
			classes[#classes + 1] = Flux::Parsing::Type:parse( source );
		while lexer:skip( Symbol, "," );

		if !lexer:skip( Symbol, ">" ) source:error "expected '>' after template";

		type = new Flux::Parsing::Type( name, classes, position );
	}
	else if !source.context.isClassname && lexer:skip( Keyword, "function" ) {
		Type returns = Flux::Parsing::Type:parse( source );
		Type[] parameters = [];

		if !lexer:skip( Symbol, "(" )
			source:error "expected '(' for function type parameters";

		if !lexer:skip( Symbol, ")" ) {
			repeat
				parameters[#parameters + 1] = Flux::Parsing::Type:parse( source );
			while lexer:skip( Symbol, "," );
			
			if !lexer:skip( Symbol, ")" )
				source:error "expected ')' after function type parameters";
		}

		type = new Flux::Parsing::Type:functionType( position, returns, parameters );
	}
	else if !source.context.isClassname && lexer:skip( Keyword, "struct" ) {
		if !lexer:skip( Symbol, "{" )
			source:error "expected '{' for struct body";

		string[] names = [];
		Type[] classes = [];

		repeat {
			if #classes > 0 && lexer:test( Identifier ) && (lexer:test( Symbol, ",", 1 ) || lexer:test( Symbol, "}", 1 )) {
				classes[#classes + 1] = classes[#classes];
				names[#names + 1] = lexer:next().value;
			}
			else {
				classes[#classes + 1] = Flux::Parsing::Type:parse( source );
				names[#names + 1] = lexer:skipValue( Identifier ) || source:error "expected struct member name";
			}
		}
		while lexer:skip( Symbol, "," );
		
		if !lexer:skip( Symbol, "}" )
			source:error "expected '}' after struct body";

		type = new Flux::Parsing::Type:structType( position, names, classes );
	}
	// add function type parsing...?
	else if !name
		source:error "expected typename";
	else
		type = new Flux::Parsing::Type( name, [], position );

	while true {
		let pos = lexer:get().position;

		if !source.context.isClassname && lexer:skip( Symbol, "[" ) {
			if !lexer:skip( Symbol, "]" ) source:error "expected ']' to close list type modifier";
			type = Flux::Parsing::Type:listType( pos, type );
		}
		else if !source.context.isClassname && lexer:skip( Symbol, "{" ) {
			if lexer:skip( Symbol, "}" )
				type = Flux::Parsing::Type:tableType( pos, type );
			else {
				let index = Flux::Parsing::Type:parse( source );
				if !lexer:skip( Symbol, "}" ) source:error "expected '}' to close array type modifier";

				type = Flux::Parsing::Type:tableType( pos, type, index );
			}
		}
		else if lexer:skip( Symbol, "&" ) {
			type = Flux::Parsing::Type:referenceType( pos, type );
		}
		else if !source.context.isClassname && lexer:skip( Symbol, "?" ) {
			type = Flux::Parsing::Type:nullableType( pos, type );
		}
		else break;
	}

	return type;
}

Type Type:autoType( Position position )
	= new Flux::Parsing::Type( "auto", [], position );

Type Type:voidType( Position position )
	= new Flux::Parsing::Type( "void", [], position );

Type Type:functionType( Position position, Type returns, Type[] parameters )
	= new Flux::Parsing::Type( "function", [returns, unpack( parameters )], position );

Type Type:listType( Position position, Type value )
	= new Flux::Parsing::Type( "List", [value], position );

Type Type:tableType( Position position, Type value, index )
	= new Flux::Parsing::Type( "Table", [value, index], position );

Type Type:referenceType( Position position, Type value )
	= new Flux::Parsing::Type( "Reference", [value], position );

Type Type:nullableType( Position position, Type value )
	= new Flux::Parsing::Type( "null", [value], position );

Type Type:structType( Position position, string[] names, Type[] types ) {
	Type[] classes = [];
	foreach i, v in names {
		classes[i] = new Flux::Parsing::Type( v, [types[i]], types[i].position );
	}
	table.sort( classes, lambda a b => a.name > b.name );
	return new Flux::Parsing::Type( "struct", classes, position );
}
