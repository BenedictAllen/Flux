
namespace Flux::Parsing;

class FunctionType extends Flux::Parsing::Type {
	ASTNodeType type = Flux::Parsing::ASTNodeType.FunctionType;
	Type returns;
	Type[] parameters;
	bool[] nullables;

	FunctionType(Type returns, Type[] parameters, bool[] nullables, null Position position = returns.position) {
		self.returns = returns;
		self.parameters = parameters;
		self.nullables = nullables;
		self.position = position;
	}
}

FunctionType FunctionType:parse( Source source ) {
	let lexer = source.lexer;
	let parameters -> Type[] = [];
	let nullables -> bool[] = [];
	let position = lexer:get().position;

	if lexer:skip( Keyword, "function" ) {
		Type returns;

		if lexer:test( Keyword, "void" )
			returns = new Flux::Parsing::Typename( "void", lexer:next().value );
		else
			returns = Flux::Parsing::Type:parse( source );

		if !lexer:skip( Symbol, "(" ) source:error "expected '('";

		if !lexer:skip( Symbol, ")" ) {
			repeat {
				nullables[#nullables + 1] = lexer:skip( Keyword, "null" ) && true || false;
				parameters[#parameters + 1] = Flux::Parsing::Type:parse( source );
			}
			while lexer:skip( Symbol, "," );

			if !lexer:skip( Symbol, ")" ) source:error "expected ')'";
		}
		
		return new Flux::Parsing::FunctionType( returns, parameters, position );
	}
}

string FunctionType:serialize() {
	string[] p = [];

	foreach i, v in self.parameters
		p[i] = (self.nullables[i] && "null " || "") `concat` v:serialize();

	return "function " `concat` self.returns:serialize() `concat` "(" `concat` table.concat( p, ", " ) `concat` ")";
}
