
import ConstantType;

namespace Flux::Parsing;

class TableExpression extends Flux::Parsing::PrimaryExpression {
	Expression[][] values;

	TableExpression(Expression[][] values, Position position) {
		self.values = values;
		self.position = position;
	}

	static ASTNode parse(Source source);
}

ASTNode TableExpression:parse(Source source)
	let position = source.lexer:get().position;
	then if source.lexer:skip(Symbol, "{") {
		Lexer lexer = source.lexer;
		Expression[][] values = [];
		int i = 0;

		if !lexer:skip(Symbol, "}") { // if the table actually has content
			repeat {
				Expression index, value; // get key, value pairs

				if lexer:skip(Symbol, "[") { // if it's a [index] = value
					index = Flux::Parsing::Expression:parse(source) || source:error "expected expression after '['";

					if !lexer:skip(Symbol, "]")
						source:error "expected ']' to close table index";
					if !lexer:skip(Symbol, "=")
						source:error "expected '=' after index";
				}

				else if lexer:test(Identifier) && lexer:test(Symbol, "=", 1) { // if it's a key = value
					let token = lexer:next();

					index = new Flux::Parsing::ConstantExpression(Flux::Parsing::ConstantType.String, token.value, token.position);

					if !lexer:skip(Symbol, "=")
						source:error "expected '=' after index";
				}

				else // if it's an array entry
					index = new Flux::Parsing::ConstantExpression(Flux::Parsing::ConstantType.Integer, tostring(i++), lexer:get().position);

				value = Flux::Parsing::Expression:parse(source) || source:error "expected expression for table value";
				values[#values + 1] = [index, value];
			}
			while lexer:skip(Symbol, ",") || lexer:skip(Symbol, ";") && !lexer:test(Symbol, "}"); // repeat while there's a comma or (; not followed by the '}')

			if !lexer:skip(Symbol, "}") source:error "expected '}' to close table";
		}

		return new Flux::Parsing::TableExpression(values, position);
	}
	else return null;

string TableExpression:serialize() {
	string[] elements = [];

	foreach i, entry in self.values
		elements[i] = "[" `concat` entry[1]:serialize() `concat` "] = " `concat` entry[2]:serialize();

	return "{\n\t" `concat` table.concat( elements, ";\n" ):gsub( "\n", "\n\t" ) `concat` ";\n}";
}
