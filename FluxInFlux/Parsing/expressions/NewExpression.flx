
import TemplatedName;
import ConstantType;

namespace Flux::Parsing;

class NewExpression extends PrimaryExpression {
	TemplatedName type;
	int[] list_sizes;
	ASTNode[] parameters;

	NewExpression(TemplatedName type, int[] list_sizes, Expression[] parameters, null Position position = _type.position) {
		self.type = type;
		self.list_sizes = list_sizes;
		self.parameters = parameters;
		self.position = position;
	}

	static ASTNode parse(Source source);
}

ASTNode NewExpression:parse( Source source ) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if !lexer:skip( Keyword, "new" ) return;

	source.file:push_context():set_flag "is_parsing_new_type";

	ASTNode type = Flux::Parsing::types::parse( source );
	ASTNode[] parameters = [];
	int[] list_sizes = [];

	source.file:pop_context();

	while lexer:skip( Symbol, "[" ) {
		int size = tostring( lexer:skipValue( Integer )
		        || source:error "expected integer after '['" );

		if !lexer:skip( Symbol, "]" )
			source:error "expected ']' after list size";

		list_sizes[#list_sizes + 1] = size;
	}

	if lexer:skip( Symbol, "(" ) {
		if !lexer:skip( Symbol, ")" ) {
			repeat
				parameters[#parameters + 1] = Flux::Parsing::Expression:parse(source) || source:error "expected parameter";
			while lexer:skip( Symbol, "," );

			if !lexer:skip( Symbol, ")" ) source:error "expected ')' to close function call";
		}
	}
	else if lexer:test( String )
		parameters[1] = new Flux::Parsing::ConstantExpression( Flux::Parsing::ConstantType.String, lexer:next().value, position );

	return new Flux::Parsing::NewExpression( type, list_sizes, parameters, position );
}

string NewExpression:serialize()
	= "new "
	`concat` self.type:serialize()
	`concat` (#self.list_sizes > 0 && "[" `concat` table.concat( self.list_sizes, "][" ) `concat` "]" || "")
	`concat` "(" `concat` (self.parameters `concattenate` ", ") `concat` ")";
