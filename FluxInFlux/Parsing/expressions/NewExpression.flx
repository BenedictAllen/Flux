
namespace Flux::Parsing;

NewExpression NewExpression:parse( Source source ) {
	let lexer = source.lexer;
	let parameters -> Expression[] = [];
	let position = lexer:get().position;

	if !lexer:skip( Keyword, "new" ) return;

	let type = Flux::Parsing::Type:parse( source );

	if lexer:skip( Symbol, "(" ) {
		if !lexer:skip( Symbol, ")" ) {
			repeat
				parameters[#parameters + 1] = Flux::Parsing::Expression:parse(source) || source:error "expected parameter";
			while lexer:skip( Symbol, "," );

			if !lexer:skip( Symbol, ")" ) source:error "expected ')' to close function call";
		}
	}
	else if lexer:test( String )
		parameters[1] = new Flux::Parsing::ConstantExpression( Flux::Parsing::ASTNodeType.StringConstant, lexer:next().value, position );

	return new Flux::Parsing::NewExpression( type, parameters, position );
}

string NewExpression:serialize()
	= "new " `concat` self._type:serialize() `concat` "(" `concat` (self.parameters `concattenate` ", ") `concat` ")";
