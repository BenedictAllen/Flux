
namespace Flux::Parsing;

ASTNode ConstantExpression:parse(Source source) {
	let token = source.lexer:get();

	if source.lexer:skip(Keyword, "null")
		return new Flux::Parsing::ConstantExpression(
			Flux::Parsing::ASTNodeType.NullConstant,
			"null",
			token.position
		);

	switch token.type;
	case String
		return new Flux::Parsing::ConstantExpression(
			Flux::Parsing::ASTNodeType.StringConstant,
			source.lexer:next().value,
			token.position
		);
	case Character
		return new Flux::Parsing::ConstantExpression(
			Flux::Parsing::ASTNodeType.CharacterConstant,
			source.lexer:next().value,
			token.position
		);
	case Integer
		return new Flux::Parsing::ConstantExpression(
			Flux::Parsing::ASTNodeType.IntegerConstant,
			source.lexer:next().value,
			token.position
		);
	case Float
		return new Flux::Parsing::ConstantExpression(
			Flux::Parsing::ASTNodeType.FloatConstant,
			source.lexer:next().value,
			token.position
		);
	case Byte
		return new Flux::Parsing::ConstantExpression(
			Flux::Parsing::ASTNodeType.ByteConstant,
			source.lexer:next().value,
			token.position
		);
	case Hexadecimal
		return new Flux::Parsing::ConstantExpression(
			Flux::Parsing::ASTNodeType.HexadecimalConstant,
			source.lexer:next().value,
			token.position
		);
	case Binary
		return new Flux::Parsing::ConstantExpression(
			Flux::Parsing::ASTNodeType.BinaryConstant,
			source.lexer:next().value,
			token.position
		);
	case Boolean
		return new Flux::Parsing::ConstantExpression(
			Flux::Parsing::ASTNodeType.BooleanConstant,
			source.lexer:next().value,
			token.position
		);
	default
		return null;
}

string ConstantExpression:serialize()
	= match self.type {
		Flux::Parsing::ASTNodeType.StringConstant => ("%q"):format( self.value );
		Flux::Parsing::ASTNodeType.CharacterConstant => "'" `concat` self.value `concat` "'";
		default => self.value;
	};
