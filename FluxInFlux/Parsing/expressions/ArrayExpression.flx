
namespace Flux::Parsing;

class ArrayExpression extends Flux::Parsing::PrimaryExpression {
	ASTNodeType type = Flux::Parsing::ASTNodeType.ArrayExpression;
	Expression[] values;

	ArrayExpression(Expression[] values, Position position) {
		self.values = values;
		self.position = position;
	}
}

ArrayExpression ArrayExpression:parse(Source source)
	let position = source.lexer:get().position;
	then if source.lexer:skip(Symbol, "[") {
		Lexer lexer = source.lexer;
		Expression[] values = [];

		if !lexer:skip(Symbol, "]") {
			repeat
				values[#values + 1] = Flux::Parsing::Expression:parse(source) || source:error "expected expression";
			while lexer:skip(Symbol, ",");

			if !lexer:skip(Symbol, "]") source:error "expected ']' to close array";
		}

		return new Flux::Parsing::ArrayExpression(values, position);
	}
	else return null;

string ArrayExpression:serialize()
	= "[" `concat` (elements `concattenate` ", ") `concat` "]";
