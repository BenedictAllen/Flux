
import TemplatedName;
import definitions.FunctionParameter;

namespace Flux::Parsing;

class FunctionExpression extends PrimaryExpression {
	FunctionParameter[] parameters;
	TemplatedName returns;
	Block body;

	FunctionExpression( FunctionParameter[] parameters, TemplatedName returns, Block body, null Position position = returns.position ) {
		self.parameters = parameters;
		self.returns = returns;
		self.body = body;
		self.position = position;
	}

	static ASTNode parse(Source source);
}

ASTNode FunctionExpression:parse( Source source ) {
	let lexer = source.lexer;
	let position = lexer:get().position;

	if lexer:skip( Keyword, "function" ) {
		TemplatedName returns = lexer:skip( Symbol, "->" ) && Flux::Parsing::types::parse( source ) || Flux::Parsing::types::auto_type( position );
		FunctionParameter[] parameters = [];
		bool is_vararg = false;

		if !lexer:skip( Symbol, "(" ) source:error "expected '(' for function parameters";

		if !lexer:skip( Symbol, ")" ) {
			FunctionParameter parameter;

			repeat {
				parameter = Flux::Parsing::FunctionParameter:parse( source, true, parameter );
				parameters[#parameters + 1] = parameter;

				if parameter.name == "..." && lexer:test( Symbol, "," )
					source:error( "unexpected ',' after vararg (...) parameter" );
			}
			while lexer:skip( Symbol, "," );

			is_vararg = parameter.name == "...";

			if !lexer:skip( Symbol, ")" ) source:error "expected ')' to close function parameters";
		}

		Block body = Flux::Parsing::parseFunctionBody( source, is_vararg );

		return new Flux::Parsing::FunctionExpression( parameters, returns, body, position );
	}
	else if lexer:skip( Keyword, "lambda" ) {
		TemplatedName returns = Flux::Parsing::types::auto_type( position );
		FunctionParameter[] parameters = [];
		Position position;

		while !lexer:skip( Symbol, "=>" ) {
			let pos = lexer:get().position;
			let name = lexer:skipValue( Identifier ) || source:error "expected parameter name";
			let ptype = lexer:skip( Symbol, "->" ) && Flux::Parsing::types::parse( source ) || Flux::Parsing::types::auto_type( pos );

			parameters[#parameters + 1] = new Flux::Parsing::FunctionParameter(ptype, name, false, pos);
			position = lexer:get().position;
		}

		let expr = Flux::Parsing::Expression:parse( source ) || source:error "expected expression after '=>'";
		let body = new Flux::Parsing::Block( [new Flux::Parsing::ReturnStatement( expr, position )], position );

		return new Flux::Parsing::FunctionExpression( parameters, returns, body, position );
	}
}

string FunctionExpression:serialize()
	= "function -> " `concat` self.returns:serialize() `concat` "(" `concat` (self.parameters `concattenate` ", ") `concat` ") "
		`concat` self.body:serialize();
