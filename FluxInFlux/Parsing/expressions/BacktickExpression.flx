
import operators.BacktickExpressionStack;

namespace Flux::Parsing;

class BacktickExpression extends RightUnaryExpression {
	Expression[] values;
	bool is_left;
	string op;

	BacktickExpression( bool is_left, Expression[] values, string op, null Position position = values[1].position ) {
		self.values = values;
		self.is_left = is_left;
		self.op = op;
		self.position = position;
	}
}

ASTNode BacktickExpression:parse( Source source ) {
	new Flux::Parsing::BacktickExpressionStack stack();

	if stack:get_initial_term( source ) {
		while stack:get_following_term( source ) {}

		return stack:result();
	}

	return null;
}

string BacktickExpression:serialize() {
	if self.is_left
		return "`" `concat` self.op `concat` "` " `concat` Flux::Parsing::serializeExpression( self.values[1] );

	return Flux::Parsing::serializeExpression( self.values[1] )
		`concat` " `" `concat` self.op `concat` "`"
		`concat` (self.values[2] && " " `concat` Flux::Parsing::serializeExpression( self.values[2] ) || "");
}
