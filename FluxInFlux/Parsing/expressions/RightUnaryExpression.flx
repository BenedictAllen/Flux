
namespace Flux::Parsing;

ASTNode RightUnaryExpression:parse(Source source) {
	let lexer = source.lexer;
	let expr = Flux::Parsing::PrimaryExpression:parse( source );

	while true {
		Expression new_expr;

		if lexer:test( Symbol, "++" ) || lexer:test( Symbol, "--" ) {
			let token = lexer:next();

			if !(expr.type == Flux::Parsing::ASTNodeType.Reference || expr.type == Flux::Parsing::ASTNodeType.Index || expr.type == Flux::Parsing::ASTNodeType.DotIndex)
				source:error( "invalid lvalue to operator '" `concat` token.value `concat` "'", expr.position );

			new_expr = new Flux::Parsing::RightUnaryExpression( expr, token.value, token.position );
		}
		else new_expr =
			Flux::Parsing::FunctionCall:parse( source, expr )
			|| Flux::Parsing::MethodCall:parse( source, expr )
			|| Flux::Parsing::Index:parse( source, expr )
			|| Flux::Parsing::DotIndex:parse( source, expr )
			|| Flux::Parsing::Cast:parse( source, expr )
			|| Flux::Parsing::OperatorImplements:parse( source, expr )
			|| Flux::Parsing::OperatorTypeof:parse( source, expr )
			|| Flux::Parsing::OperatorExtends:parse( source, expr )
		;

		if new_expr expr = new_expr;
		else break;
	}
	
	return expr;
}

string RightUnaryExpression:serialize()
	= value `concat` self.op
	where value = Flux::Parsing::serializeExpression(self.value);
