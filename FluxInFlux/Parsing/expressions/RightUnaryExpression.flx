
import FunctionCall;
import MethodCall;
import Index;
import DotIndex;
import Cast;
import OperatorExtends;
import OperatorImplements;
import OperatorTypeof;

namespace Flux::Parsing;

class RightUnaryExpression extends Flux::Parsing::PrimaryExpression {
	Expression value;
	string op;

	RightUnaryExpression(Expression value, string op, null Position position = value.position) {
		self.value = value;
		self.op = op;
		self.position = position;
	}
}

ASTNode RightUnaryExpression:parse( Source source, null Expression expr = Flux::Parsing::PrimaryExpression:parse( source ) ) {
	let lexer = source.lexer;

	while true {
		Expression new_expr;

		if lexer:test( Symbol, "++" ) || lexer:test( Symbol, "--" ) {
			let token = lexer:next();

			new_expr = new Flux::Parsing::RightUnaryExpression( expr, token.value, token.position );
		}
		else new_expr =
			Flux::Parsing::FunctionCall:parse( source, expr )
			|| Flux::Parsing::MethodCall:parse( source, expr )
			|| Flux::Parsing::Index:parse( source, expr )
			|| Flux::Parsing::DotIndex:parse( source, expr )
			|| Flux::Parsing::Cast:parse( source, expr )
			|| Flux::Parsing::OperatorImplements:parse( source, expr )
			|| Flux::Parsing::OperatorTypeof:parse( source, expr )
			|| Flux::Parsing::OperatorExtends:parse( source, expr )
		;

		if new_expr expr = new_expr;
		else break;
	}

	return expr;
}

string RightUnaryExpression:serialize()
	= value `concat` self.op
	where value = Flux::Parsing::serializeExpression(self.value);
