
namespace Flux::Parsing;

class Index extends RightUnaryExpression {
	Expression value;
	Expression[] index;

	Index( Expression value, Expression[] index, null Position position = value.position ) {
		self.value = value;
		self.index = index;
		self.position = position;
	}

	static ASTNode parse(Source source);
}

ASTNode Index:parse( Source source, Expression value ) {
	let lexer = source.lexer;
	let index -> Expression[] = [];
	let position = lexer:get().position;

	if lexer:skip( Symbol, "[" ) {
		repeat
			index[#index + 1] = Flux::Parsing::Expression:parse(source) || source:error "expected index";
		while lexer:skip( Symbol, "," );

		if !lexer:skip( Symbol, "]" ) source:error "expected ']' to close index";

		return new Flux::Parsing::Index( value, index, position );
	}
}

string Index:serialize()
	= Flux::Parsing::serializeExpression( self.value ) `concat` "[" `concat` (self.index `concattenate` ", ") `concat` "]";
