
namespace Flux::Parsing;

ASTNode LeftUnaryExpression:parse(Source source) {
	let lexer = source.lexer;

	if !lexer:test(Symbol)
		return Flux::Parsing::RightUnaryExpression:parse(source);

	let op = match lexer:get().value {
		"++" => "++";
		"--" => "--";
		"!" => "!";
		"~" => "~";
		"#" => "#";
		"-" => "-";
	};

	if op {
		let position = lexer:next().position;
		let lvalue = Flux::Parsing::LeftUnaryExpression:parse(source);

		if !(lvalue.type == Flux::Parsing::ASTNodeType.Reference || lvalue.type == Flux::Parsing::ASTNodeType.Index || lvalue.type == Flux::Parsing::ASTNodeType.DotIndex)
			source:error( "invalid rvalue to operator '" `concat` op `concat` "'", lvalue.position );

		return new Flux::Parsing::LeftUnaryExpression( lvalue, op, position );
	}
	else
		return Flux::Parsing::OperatorTypeof:parse(source) || Flux::Parsing::RightUnaryExpression:parse(source);
}

string LeftUnaryExpression:serialize()
	= self.op `concat` value
	where value = Flux::Parsing::serializeExpression(self.value);
