
namespace Flux::Parsing;

string LeftUnaryOperatorTostring(LeftUnaryOperator op)
	= match op {
		Flux::Parsing::LeftUnaryOperator.Increment => "++";
		Flux::Parsing::LeftUnaryOperator.Decrement => "--";
		Flux::Parsing::LeftUnaryOperator.Not => "!";
		Flux::Parsing::LeftUnaryOperator.BNot => "~";
		Flux::Parsing::LeftUnaryOperator.Length => "#";
		Flux::Parsing::LeftUnaryOperator.Minus => "-";
	};

ASTNode LeftUnaryExpression:parse(Source source) {
	let lexer = source.lexer;

	if !lexer:test(Symbol)
		return Flux::Parsing::RightUnaryExpression:parse(source);

	let op = match lexer:get().value {
		"++" => Flux::Parsing::LeftUnaryOperator.Increment;
		"--" => Flux::Parsing::LeftUnaryOperator.Decrement;
		"!" => Flux::Parsing::LeftUnaryOperator.Not;
		"~" => Flux::Parsing::LeftUnaryOperator.BNot;
		"#" => Flux::Parsing::LeftUnaryOperator.Length;
		"-" => Flux::Parsing::LeftUnaryOperator.Minus;
		default => null;
	};

	if op
		let position = lexer:next().position;
		then return new Flux::Parsing::LeftUnaryExpression(Flux::Parsing::LeftUnaryExpression:parse(source), op, position);
	else
		return Flux::Parsing::OperatorTypeof:parse(source) || Flux::Parsing::RightUnaryExpression:parse(source);
}

string LeftUnaryExpression:serialize()
	= Flux::Parsing::LeftUnaryOperatorTostring(self.op) `concat` value
	where value = Flux::Parsing::serializeExpression(self.value);
