
namespace Flux::Parsing::Operator;

void register_binary(string op, int precedence, bool left_assoc) {
	Flux::Parsing::Operator::binary_operators
	[#Flux::Parsing::Operator::binary_operators + 1]
		= new Flux::Parsing::Operator::Binary( op, precedence, left_assoc );

	// print( "Registering binary operator '" `concat` op `concat` "'" );

	if op:sub( 1, 1 ) != ">" || #op == 1
		Flux::Parsing::language::symbols[op] = true;

	Flux::Parsing::Operator::operators[op] = true;
}

bool is_binary(string op) {
	foreach op_i in Flux::Parsing::Operator::binary_operators
		if op_i.symbol == op
			return true;
}

Binary get_binary(string op) {
	foreach op_i in Flux::Parsing::Operator::binary_operators
		if op_i.symbol == op
			return op_i;

	throw new StupidDerp "This really should never happen, make sure you've checked is_binary() before calling this";
}

void set_unary_precedence(UnaryOpcode a, UnaryOpcode b) {
	let unary_precedences = Flux::Parsing::Operator::unary_precedences;

	unary_precedences[a] = unary_precedences[a] || {};
	unary_precedences[b] = unary_precedences[b] || {};
	unary_precedences[a][b] = true;
	unary_precedences[b][a] = false;
}

bool get_unary_precedence(UnaryOpcode a, UnaryOpcode b) {
	if Flux::Parsing::Operator::unary_precedences[a]
		return Flux::Parsing::Operator::unary_precedences[a][b];
	return false;
}

void register_unary_symbol(string symbol, UnaryOpcode code, bool is_left) {
	Flux::Parsing::Operator::unary_symbols[symbol] = code;
	Flux::Parsing::Operator::unary_is_left[code] = is_left;

	Flux::Parsing::language::symbols[symbol] = true;
	Flux::Parsing::Operator::operators[symbol] = true;
}

void register_unary_string(string string, UnaryOpcode code, bool is_left) {
	Flux::Parsing::Operator::unary_strings[string] = code;
	Flux::Parsing::Operator::unary_is_left[code] = is_left;

	Flux::Parsing::Operator::operators[string] = true;
}

UnaryOpcode get_unary_opcode(Source source) {
	if source.lexer:test( Keyword )
		return Flux::Parsing::Operator::unary_strings[source.lexer:get().value]
		    || Flux::Parsing::Operator::UnaryOpcode.None;
	else if source.lexer:test( Symbol )
		return Flux::Parsing::Operator::unary_symbols[source.lexer:get().value]
		    || Flux::Parsing::Operator::UnaryOpcode.None;
	else if source.lexer:test( String )
		return Flux::Parsing::Operator::UnaryOpcode.Call;

	return Flux::Parsing::Operator::UnaryOpcode.None;
}

bool is_unary_left_operator(UnaryOpcode opcode)
	= Flux::Parsing::Operator::unary_is_left[opcode];

void init_standard_operators() {
	// binary equality operators
	Flux::Parsing::Operator::register_binary( "=", 1, false );

	Flux::Parsing::Operator::register_binary( "+=", 1, false );
	Flux::Parsing::Operator::register_binary( "-=", 1, false );
	Flux::Parsing::Operator::register_binary( "*=", 1, false );
	Flux::Parsing::Operator::register_binary( "/=", 1, false );
	Flux::Parsing::Operator::register_binary( "%=", 1, false );
	Flux::Parsing::Operator::register_binary( "**=", 1, false );

	Flux::Parsing::Operator::register_binary( "&=", 1, false );
	Flux::Parsing::Operator::register_binary( "|=", 1, false );
	Flux::Parsing::Operator::register_binary( "^=", 1, false );
	Flux::Parsing::Operator::register_binary( "<<=", 1, false );
	Flux::Parsing::Operator::register_binary( ">>=", 1, false );

	Flux::Parsing::Operator::register_binary( "&&=", 1, false );
	Flux::Parsing::Operator::register_binary( "||=", 1, false );

	// binary logical operators
	Flux::Parsing::Operator::register_binary( "||", 2, true );
	Flux::Parsing::Operator::register_binary( "&&", 3, true );

	// binary comparison operators
	Flux::Parsing::Operator::register_binary( ">", 4, true );
	Flux::Parsing::Operator::register_binary( "<", 4, true );
	Flux::Parsing::Operator::register_binary( "<=", 4, true );
	Flux::Parsing::Operator::register_binary( ">=", 4, true );
	Flux::Parsing::Operator::register_binary( "==", 4, true );
	Flux::Parsing::Operator::register_binary( "!=", 4, true );

	// binary range operator
	Flux::Parsing::Operator::register_binary( "..", 5, true );

	// binary bitwise operators
	Flux::Parsing::Operator::register_binary( "|", 6, true );
	Flux::Parsing::Operator::register_binary( "&", 7, true );
	Flux::Parsing::Operator::register_binary( "^", 8, true );
	Flux::Parsing::Operator::register_binary( "<<", 9, true );
	Flux::Parsing::Operator::register_binary( ">>", 9, true );

	// binary arithmetic operators
	Flux::Parsing::Operator::register_binary( "+", 10, true );
	Flux::Parsing::Operator::register_binary( "-", 10, true );
	Flux::Parsing::Operator::register_binary( "*", 11, true );
	Flux::Parsing::Operator::register_binary( "/", 11, true );
	Flux::Parsing::Operator::register_binary( "%", 11, true );
	Flux::Parsing::Operator::register_binary( "**", 12, false );

	Flux::Parsing::Operator::register_unary_symbol( "++", Flux::Parsing::Operator::UnaryOpcode.PlusPlus, true );
	Flux::Parsing::Operator::register_unary_symbol( "--", Flux::Parsing::Operator::UnaryOpcode.MinusMinus, true );
	Flux::Parsing::Operator::register_unary_symbol( "#", Flux::Parsing::Operator::UnaryOpcode.Len, true );
	Flux::Parsing::Operator::register_unary_symbol( "!", Flux::Parsing::Operator::UnaryOpcode.Not, true );
	Flux::Parsing::Operator::register_unary_symbol( "~", Flux::Parsing::Operator::UnaryOpcode.BNot, true );
	Flux::Parsing::Operator::register_unary_symbol( "-", Flux::Parsing::Operator::UnaryOpcode.Unm, true );
	Flux::Parsing::Operator::register_unary_symbol( "+", Flux::Parsing::Operator::UnaryOpcode.Unp, true );
	Flux::Parsing::Operator::register_unary_symbol( "*", Flux::Parsing::Operator::UnaryOpcode.Deref, true );

	Flux::Parsing::Operator::register_unary_symbol( "(", Flux::Parsing::Operator::UnaryOpcode.Call, false );
    Flux::Parsing::Operator::register_unary_symbol( ":", Flux::Parsing::Operator::UnaryOpcode.MethodCall, false );

	Flux::Parsing::Operator::register_unary_symbol( ".", Flux::Parsing::Operator::UnaryOpcode.DotIndex, false );
	Flux::Parsing::Operator::register_unary_symbol( "[", Flux::Parsing::Operator::UnaryOpcode.Index, false );

	Flux::Parsing::Operator::register_unary_symbol( "->", Flux::Parsing::Operator::UnaryOpcode.Cast, false );

	Flux::Parsing::Operator::register_unary_string( "extends", Flux::Parsing::Operator::UnaryOpcode.Extends, false );
	Flux::Parsing::Operator::register_unary_string( "implements", Flux::Parsing::Operator::UnaryOpcode.Implements, false );
	Flux::Parsing::Operator::register_unary_string( "typeof", Flux::Parsing::Operator::UnaryOpcode.Typeof, true );

	// set up right unary operators to have higher precedence than left ones

	let UnaryOpcode = Flux::Parsing::Operator::UnaryOpcode;
	let set_unary_precedence = Flux::Parsing::Operator::set_unary_precedence;

	set_unary_precedence( UnaryOpcode.Call, UnaryOpcode.PlusPlus ); // ++f() -> ++(f())
	set_unary_precedence( UnaryOpcode.Call, UnaryOpcode.MinusMinus ); // --f() -> --(f())
	set_unary_precedence( UnaryOpcode.Call, UnaryOpcode.Len ); // #f() -> #(f())
	set_unary_precedence( UnaryOpcode.Call, UnaryOpcode.Not ); // !f() -> !(f())
	set_unary_precedence( UnaryOpcode.Call, UnaryOpcode.BNot ); // ~f() -> ~(f())
	set_unary_precedence( UnaryOpcode.Call, UnaryOpcode.Unm ); // -f() -> -(f())
	set_unary_precedence( UnaryOpcode.Call, UnaryOpcode.Unp ); // +f() -> +(f())
	set_unary_precedence( UnaryOpcode.Call, UnaryOpcode.Deref ); // *f() -> *(f())

	set_unary_precedence( UnaryOpcode.MethodCall, UnaryOpcode.PlusPlus ); // ++x:f() -> ++(x:f())
	set_unary_precedence( UnaryOpcode.MethodCall, UnaryOpcode.MinusMinus ); // --x:f() -> --(x:f())
	set_unary_precedence( UnaryOpcode.MethodCall, UnaryOpcode.Len ); // #x:f() -> #(x:f())
	set_unary_precedence( UnaryOpcode.MethodCall, UnaryOpcode.Not ); // !x:f() -> !(x:f())
	set_unary_precedence( UnaryOpcode.MethodCall, UnaryOpcode.BNot ); // ~x:f() -> ~(x:f())
	set_unary_precedence( UnaryOpcode.MethodCall, UnaryOpcode.Unm ); // -x:f() -> -(x:f())
	set_unary_precedence( UnaryOpcode.MethodCall, UnaryOpcode.Unp ); // +x:f() -> +(x:f())
	set_unary_precedence( UnaryOpcode.Deref, UnaryOpcode.MethodCall ); // *x:f() -> (*x):f()

	set_unary_precedence( UnaryOpcode.DotIndex, UnaryOpcode.PlusPlus ); // ++a.b -> ++(a.b)
	set_unary_precedence( UnaryOpcode.DotIndex, UnaryOpcode.MinusMinus ); // --a.b -> --(a.b)
	set_unary_precedence( UnaryOpcode.DotIndex, UnaryOpcode.Len ); // #a.b -> #(a.b)
	set_unary_precedence( UnaryOpcode.DotIndex, UnaryOpcode.Not ); // !a.b -> !(a.b)
	set_unary_precedence( UnaryOpcode.DotIndex, UnaryOpcode.BNot ); // ~a.b -> ~(a.b)
	set_unary_precedence( UnaryOpcode.DotIndex, UnaryOpcode.Unm ); // -a.b -> -(a.b)
	set_unary_precedence( UnaryOpcode.DotIndex, UnaryOpcode.Unp ); // +a.b -> +(a.b)
	set_unary_precedence( UnaryOpcode.Deref, UnaryOpcode.DotIndex ); // *a.b -> (*a).b

	set_unary_precedence( UnaryOpcode.Index, UnaryOpcode.PlusPlus ); // ++x[i] -> ++(x[i])
	set_unary_precedence( UnaryOpcode.Index, UnaryOpcode.MinusMinus ); // --x[i] -> --(x[i])
	set_unary_precedence( UnaryOpcode.Index, UnaryOpcode.Len ); // #x[i] -> #(x[i])
	set_unary_precedence( UnaryOpcode.Index, UnaryOpcode.Not ); // !x[i] -> !(x[i])
	set_unary_precedence( UnaryOpcode.Index, UnaryOpcode.BNot ); // ~x[i] -> ~(x[i])
	set_unary_precedence( UnaryOpcode.Index, UnaryOpcode.Unm ); // -x[i] -> -(x[i])
	set_unary_precedence( UnaryOpcode.Index, UnaryOpcode.Unp ); // +x[i] -> +(x[i])
	set_unary_precedence( UnaryOpcode.Index, UnaryOpcode.Deref ); // *x[i] -> *(x[i])

	set_unary_precedence( UnaryOpcode.PlusPlus, UnaryOpcode.Cast ); // ++x -> T -> (++x) -> T
	set_unary_precedence( UnaryOpcode.MinusMinus, UnaryOpcode.Cast ); // --x -> T -> (--x) -> T
	set_unary_precedence( UnaryOpcode.Len, UnaryOpcode.Cast ); // #x -> T -> (#x) -> T
	set_unary_precedence( UnaryOpcode.Not, UnaryOpcode.Cast ); // !x -> T -> (!x) -> T
	set_unary_precedence( UnaryOpcode.BNot, UnaryOpcode.Cast ); // ~x -> T -> (~x) -> T
	set_unary_precedence( UnaryOpcode.Unm, UnaryOpcode.Cast ); // -x -> T -> (-x) -> T
	set_unary_precedence( UnaryOpcode.Unp, UnaryOpcode.Cast ); // +x -> T -> (+x) -> T
	set_unary_precedence( UnaryOpcode.Deref, UnaryOpcode.Cast ); // *x -> T -> (*x) -> T

	set_unary_precedence( UnaryOpcode.PlusPlus, UnaryOpcode.Extends ); // ++x extends T -> (++x) extends T
	set_unary_precedence( UnaryOpcode.MinusMinus, UnaryOpcode.Extends ); // --x extends T -> (--x) extends T
	set_unary_precedence( UnaryOpcode.Len, UnaryOpcode.Extends ); // #x extends T -> (#x) extends T
	set_unary_precedence( UnaryOpcode.Not, UnaryOpcode.Extends ); // !x extends T -> (!x) extends T
	set_unary_precedence( UnaryOpcode.BNot, UnaryOpcode.Extends ); // ~x extends T -> (~x) extends T
	set_unary_precedence( UnaryOpcode.Unm, UnaryOpcode.Extends ); // -x extends T -> (-x) extends T
	set_unary_precedence( UnaryOpcode.Unp, UnaryOpcode.Extends ); // +x extends T -> (+x) extends T
	set_unary_precedence( UnaryOpcode.Deref, UnaryOpcode.Extends ); // *x extends T -> (*x) extends T

	set_unary_precedence( UnaryOpcode.PlusPlus, UnaryOpcode.Implements );  // ++x implements T -> (++x) implements T
	set_unary_precedence( UnaryOpcode.MinusMinus, UnaryOpcode.Implements );  // --x implements T -> (--x) implements T
	set_unary_precedence( UnaryOpcode.Len, UnaryOpcode.Implements );  // #x implements T -> (#x) implements T
	set_unary_precedence( UnaryOpcode.Not, UnaryOpcode.Implements );  // !x implements T -> (!x) implements T
	set_unary_precedence( UnaryOpcode.BNot, UnaryOpcode.Implements );  // ~x implements T -> (~x) implements T
	set_unary_precedence( UnaryOpcode.Unm, UnaryOpcode.Implements );  // -x implements T -> (-x) implements T
	set_unary_precedence( UnaryOpcode.Unp, UnaryOpcode.Implements );  // +x implements T -> (+x) implements T
	set_unary_precedence( UnaryOpcode.Deref, UnaryOpcode.Implements );  // *x implements T -> (*x) implements T

	set_unary_precedence( UnaryOpcode.PlusPlus, UnaryOpcode.Typeof );  // ++x typeof T -> (++x) typeof T
	set_unary_precedence( UnaryOpcode.MinusMinus, UnaryOpcode.Typeof );  // --x typeof T -> (--x) typeof T
	set_unary_precedence( UnaryOpcode.Len, UnaryOpcode.Typeof );  // #x typeof T -> (#x) typeof T
	set_unary_precedence( UnaryOpcode.Not, UnaryOpcode.Typeof );  // !x typeof T -> (!x) typeof T
	set_unary_precedence( UnaryOpcode.BNot, UnaryOpcode.Typeof );  // ~x typeof T -> (~x) typeof T
	set_unary_precedence( UnaryOpcode.Unm, UnaryOpcode.Typeof );  // -x typeof T -> (-x) typeof T
	set_unary_precedence( UnaryOpcode.Unp, UnaryOpcode.Typeof );  // +x typeof T -> (+x) typeof T
	set_unary_precedence( UnaryOpcode.Deref, UnaryOpcode.Typeof );  // *x typeof T -> (*x) typeof T

	// x++ rather than ++x
	set_unary_precedence( UnaryOpcode.PlusPlus, UnaryOpcode.Len ); // #x++ -> #(x++)
	set_unary_precedence( UnaryOpcode.PlusPlus, UnaryOpcode.Not ); // !x++ -> !(x++)
	set_unary_precedence( UnaryOpcode.PlusPlus, UnaryOpcode.BNot ); // ~x++ -> ~(x++)
	set_unary_precedence( UnaryOpcode.PlusPlus, UnaryOpcode.Unm ); // -x++ -> -(x++)
	set_unary_precedence( UnaryOpcode.PlusPlus, UnaryOpcode.Unp ); // +x++ -> +(x++)
	set_unary_precedence( UnaryOpcode.Deref, UnaryOpcode.PlusPlus ); // *x++ -> (*x)++

	set_unary_precedence( UnaryOpcode.MinusMinus, UnaryOpcode.Len ); // #x-- -> #(x--)
	set_unary_precedence( UnaryOpcode.MinusMinus, UnaryOpcode.Not ); // !x-- -> !(x--)
	set_unary_precedence( UnaryOpcode.MinusMinus, UnaryOpcode.BNot ); // ~x-- -> ~(x--)
	set_unary_precedence( UnaryOpcode.MinusMinus, UnaryOpcode.Unm ); // -x-- -> -(x--)
	set_unary_precedence( UnaryOpcode.MinusMinus, UnaryOpcode.Unp ); // +x-- -> +(x--)
	set_unary_precedence( UnaryOpcode.Deref, UnaryOpcode.MinusMinus ); // *x-- -> (*x)--

}

let _ = (function() {
	Flux::Parsing::Operator::operators = [];
	Flux::Parsing::Operator::binary_operators = [];
	Flux::Parsing::Operator::unary_precedences = {};
	Flux::Parsing::Operator::unary_strings = {};
	Flux::Parsing::Operator::unary_symbols = {};
	Flux::Parsing::Operator::unary_is_left = {};
})();
