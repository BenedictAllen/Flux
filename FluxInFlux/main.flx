
import flux;

let source_code = '
namespace N;
int i = 0;

int f() {
	int a = 0;
}
';

void main() {
	new Flux::Parsing::Source source();
	new Flux::Parsing::Lexer lexer( source_code );
	new Flux::Parsing::Context context();

	context.isNamespace = true;

	source.context = context;
	source.contexts[1] = context;
	source.lexer = lexer;

	while !lexer:isEOF() {
		Flux::Parsing::Statement:parse( source );
	}

	foreach expr in source.statements
		print( expr:serialize() `concat` "\n" );

	new IRContext c();

	c:pushScope();
	c:use "a";
	c:define("b::c", true, new IRClassType([]), new Flux::Position("dashjk", 1, 1, 1));
	c:define("a::b::c", true, new IRClassType([]), new Flux::Position("dashjk", 1, 1, 1));
	// c:pushScope();

	foreach v in c:lookup "b::c"
		print( c.heap:lookup( v ).name ); // a::b::c, b::c
}

