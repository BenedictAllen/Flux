let source_code = '
@flagcdef native-IntConstant
const final class int implements IAddable, ISubtractable, IProductable, IDivisable, IModdable, IExponentable {
	int operator+(int);
	int operator-(int);
	int operator*(int);
	int operator/(int);
	int operator%(int);
	int operator**(int);
}

@flagcdef native-FloatConstant
const final class float {

}
';

import flux;

void main() {
	new Flux::Parsing::Source source();
	new Flux::Parsing::Lexer lexer( source_code );
	new Flux::Parsing::Context context();

	context.isNamespace = true;

	source.context = context;
	source.contexts[1] = context;
	source.lexer = lexer;

	while !lexer:isEOF() {
		Flux::Parsing::Statement:parse( source );
	}

	foreach expr in source.statements
		print( expr:serialize() `concat` "\n" );

	new IRContext c();

	new IRType t1(c.heap, new IRTypeSignature("t1", []));
	new IRType t2(c.heap, new IRTypeSignature("t2", []));
	new IRType t3(c.heap, new IRTypeSignature("t3", []));
	new IRType t4(c.heap, new IRTypeSignature("t4", []));

	c:pushScope();
	c:use "a";
	c:use "b";
	c:define("a::f", true, t1, new Flux::Position("dashjk", 1, 1, 1));
	c:define("f", true, t2, new Flux::Position("dashjk", 1, 1, 1));
	c:define("b::f", true, t3, new Flux::Position("dashjk", 1, 1, 1));
	c:define("a::f", true, t4, new Flux::Position("dashjk", 1, 1, 1));

	foreach v in c:lookup "f"
		print( c.heap:lookup( v ).type.signature.name );
}
