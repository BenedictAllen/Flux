
import flux;

let source_code = '
void cls<T>:something() {
	return 5;
}
';

void main() {
	new Flux::Parsing::Source source();
	new Flux::Parsing::Lexer lexer( source_code );
	new Flux::Parsing::Context context();

	context.isNamespace = true;

	source.context = context;
	source.contexts[1] = context;
	source.lexer = lexer;

	while !lexer:isEOF() {
		Flux::Parsing::Statement:parse( source );
	}

	foreach expr in source.statements
		print( expr:serialize() `concat` "\n" );

	new IRContext c();

	new IRClassType t1([]);
	new IRClassType t2([]);
	new IRClassType t3([]);
	new IRClassType t4([]);

	c:pushScope();
	c:use "a";
	c:use "b";
	c:define("a::f", true, t1, new Flux::Position("dashjk", 1, 1, 1));
	c:define("f", true, t2, new Flux::Position("dashjk", 1, 1, 1));
	c:define("b::f", true, t3, new Flux::Position("dashjk", 1, 1, 1));
	c:define("a::f", true, t4, new Flux::Position("dashjk", 1, 1, 1));

	foreach v in c:lookup "f"
		print( match c.heap:lookup( v ).type {
			t1 => "t1";
			t2 => "t2";
			t3 => "t3";
			t4 => "t4";
			default => "none";
		} );
}
