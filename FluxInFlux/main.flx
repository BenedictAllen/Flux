
import flux;

let source_code = '
// template<T>
// class Reference /*<T>* /
class Reference {
	T value;

	Reference(auto vararg);
	Reference(T v) value = v;

	auto operator+(auto v) = value + v;
	auto operator-(auto v) = value - v;
	auto operator*(auto v) = value * v;
	auto operator/(auto v) = value / v;

	T operator^() = value;
}

template<T>
Reference<T>:Reference(auto vararg) {
	self.value = new T(vararg);
}

int& i = 0;
';

void main() {
	new Flux::Parsing::Source source();
	new Flux::Parsing::Lexer lexer( source_code );
	new Flux::Parsing::Context context();

	context.isNamespace = true;

	source.context = context;
	source.contexts[1] = context;
	source.lexer = lexer;

	while !lexer:isEOF() {
		Flux::Parsing::Statement:parse( source );
	}

	foreach expr in source.statements
		print( expr:serialize() `concat` "\n" );
}

