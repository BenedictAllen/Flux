
let source_code = '

class byte;
class int;
class float;

@flagcdef native-ByteConstant
@flagcdef force-inline
const final class byte implements IAddable, ISubtractable, IModdable {
	byte() = 0b;
	byte(byte);

	byte operator+(byte);
	byte operator-(byte);
	byte operator%(byte);

	byte operator&(byte);
	byte operator|(byte);
	byte operator^(byte);
	byte operator<<(byte);
	byte operator>>(byte);

	byte operator~();

	int operator->();
	float operator->();
}

@flagcdef native-IntConstant
@flagcdef force-inline
const final class int implements IAddable, ISubtractable, IProductable, IDivisable, IModdable, IExponentable {
	int() = 0;
	int(int);

	int operator+(int);
	int operator-(int);
	int operator*(int);
	int operator/(int);
	int operator%(int);
	int operator**(int);

	int operator&(int);
	int operator|(int);
	int operator^(int);
	int operator<<(int);
	int operator>>(int);

	int operator~();
	int operator-();

	byte operator->();
	float operator->();
}

@flagcdef native-FloatConstant
@flagcdef force-inline
const final class float implements IAddable, ISubtractable, IProductable, IDivisable, IModdable, IExponentable {
	float() = 0.0;
	float(float);

	float operator+(float);
	float operator-(float);
	float operator*(float);
	float operator/(float);
	float operator%(float);
	float operator**(float);

	float operator-();

	byte operator->();
	int operator->();
}

// an N dimensional vector, meant to be extended
template<T [float, int]>
abstract class Vector<T> {
	T[] objects;

	Vector<T> operator+(Vector<T> value);
	Vector<T> operator-(Vector<T> value);
	Vector<T> operator*(float value);
	Vector<T> operator/(float value);

	float dot(Vector<T> value);
	Vector<T> cross(Vector<T> value);
}

template<T>
class Vector2D<T> extends Vector<T> {
	Vector2D(T x, y);

	T getter x() = objects[0];
	T getter y() = objects[1];

	T setter x(T x) objects[0] = x;
	T setter y(T y) objects[1] = y;
}

template<T>
Vector2D<T>:Vector2D(T x, y) {
	objects[0] = x;
	objects[1] = y;
}

class Vec2 = Vector2D<float>;

class Something {
	float x, y, z;
	string something = "blah";

	Something(float x, y, z);
}

Something:Something(float _x, _y, _z) {
	x = _x; y = _y; z = _z;
}

void f(struct {float x, y} v) {
	print( v.x, v.y );
}

f( new Vector2D<float>(1.0, 2.0) ); // 1.0, 2.0
f( new Something(5.0, 7.0, 9.0) ); // 5.0, 7.0
f( new Vec2(3.0, 4.0) ); // 3.0, 4.0

int main() {
	print "Hi";

	let x = 5;

	while 1 > 2 {
		if a > 2
			print "yah";
	}
}
';

import flux;

void main() {
	new Flux::Parsing::Source source();
	new Flux::Parsing::Lexer lexer( source_code );
	new Flux::Parsing::Context context();

	context.isNamespace = true;

	source.context = context;
	source.contexts[1] = context;
	source.lexer = lexer;

	while !lexer:isEOF() {
		Flux::Parsing::Statement:parse( source );
	}

	foreach expr in source.statements
		_; // print( expr:serialize() `concat` "\n" );

	new IRContext c();

	c:loadfile "main";
	c:pushScope();

	new IRClassDefinition t1();
	new IRClassDefinition t2();
	new IRClassDefinition t3();
	new IRClassDefinition t4();

	t1.name = "1";
	t2.name = "2";
	t3.name = "3";
	t4.name = "4";

	c:define( t1 );
	c:define( t2 );
	c:define( t3 );
	c:define( t4 );

	let t1p = c:lookupType( "1", true ) || throw new Error "So the type 1 doesn't exist :/";
	let t2p = c:lookupType( "2", true ) || throw new Error "So the type 2 doesn't exist :/";
	let t3p = c:lookupType( "3", true ) || throw new Error "So the type 3 doesn't exist :/";
	let t4p = c:lookupType( "4", true ) || throw new Error "So the type 4 doesn't exist :/";

	new IRTypeSignature s1(t1p, []);
	new IRTypeSignature s2(t2p, []);
	new IRTypeSignature s3(t3p, []);

	t1.super = t2p;

	print( new IRTypeSignature(IRDefinitionPointer.null_type, [s1]):compare( new IRTypeSignature(IRDefinitionPointer.null_type, [s3]) ) );

	/*
	c:use "a";
	c:use "b";

	c:define(new IRObjectDefinition("a::f", true, true, t2p, [], new Flux::Position("dashjk", 1, 1, 1)));
	c:define(new IRObjectDefinition("f", true, false, t1p, [], new Flux::Position("dashjk", 1, 1, 1)));
	c:define(new IRObjectDefinition("b::f", true, false, t4p, [], new Flux::Position("dashjk", 1, 1, 1)));
	c:define(new IRObjectDefinition("a::f", true, true, t3p, [], new Flux::Position("dashjk", 1, 1, 1)));

	foreach v in c:lookup( "f", true )
		print( v:definition().type:definition().name );

	foreach f in c.files[c.filenames[#c.filenames]]:lookup( "a::f", true )
		print( f:definition().type:definition().name );
	*/
}
// */
