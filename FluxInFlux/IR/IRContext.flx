
// namespace Flux::Compiling;

void IRContext:define( IRDefinition def ) {
	self.scopes[#self.scopes]:define( def );
}

IRDefinitionPointer[] IRContext:lookup(string name, bool hasPrivate) {
	IRScope global = self.scopes[1];
	IRDefinitionPointer[] found = [];
	string[] isUsing = [];

	for (int i = #self.scopes, i > 1, i--) {
		let found = self.scopes[i]:lookup( name, hasPrivate );
		if #found > 0 return found;

		foreach u in self.scopes[i].isUsing
			isUsing[#isUsing + 1] = u;
	}

	foreach s in self.scopes
		foreach u in s.isUsing
			isUsing[#isUsing + 1] = u;

	foreach v in global:lookup( name, hasPrivate )
		found[#found + 1] = v;

	foreach u in isUsing
		foreach v in global:lookup( table.concat( [u, name], "::" ), hasPrivate )
			found[#found + 1] = v;

	return found;
}

IRDefinitionPointer IRContext:lookupType(string name, bool hasPrivate) {
	IRDefinitionPointer[] list = self:lookup(name, hasPrivate);
	IRDefinitionPointer type = list[#list];

	if type:definition() typeof IRClassDefinition
	|| type:definition() typeof IREnumDefinition
	|| type:definition() typeof IRInterfaceDefinition
		return type;

	return null;
}

void IRContext:loadfile(string filename) {
	self.filenames[#self.filenames] = filename;
	self.files[self.filenames[#self.filenames]] = new IRDefinitionHeap();
}

void IRContext:donefile()
	self.filenames[#self.filenames] = null;

void IRContext:error(string err, Position position) {
	return error( table.concat( [position.source, "[", position.line, ", ", position.character, "]: ", err] ), 0 );
}

IRScope IRContext:pushScope() {
	let scope = new IRScope( self.files[self.filenames[#self.filenames]] );
	self.scopes[#self.scopes + 1] = scope;
	return scope;
}

IRScope IRContext:popScope() {
	return table.remove( self.scopes, #self.scopes );
}

void IRContext:use( string name ) {
	self.scopes[#self.scopes]:use( name );
}
