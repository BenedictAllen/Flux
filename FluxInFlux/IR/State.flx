
import Parsing.imports.Source;
import File;
import Position;
import Declaration;
import constants;
import definitions.EnumDefinition;
import lookup_utils;

namespace Flux::IR;

class State {
	File{string} files;
	File active_file;
	Scope[] working_scope_stack;

	State() {
		self.files = {};
		self.working_scope_stack = [];
	}

	private:
	void initialise_ast_file(Parsing::File file);
	void load_ast_file_types(Parsing::File file);
	void load_ast_file_header(Parsing::File file);
	void load_ast_file_source(Parsing::File file);

	string format_err_msg(string err, Position pos);

	Declaration[] lookup(string name);
	Declaration[] lookup_exact(string name);

	public:
	void load_ast(Source source);

	void error(string err, Position position);
	void warn(string err, Position position);
}

void State:initialise_ast_file(Parsing::File file) {
	new Flux::IR::File ir_file( file.name );

	print( "@" `concat` file.name );

	return ir_file;
}

void State:load_ast_file_types(Parsing::File file) {
	foreach t in file.types {
		if t.type == Flux::Parsing::Type.ENUM {
			self.active_file.local_scope:define(
				new Flux::IR::Declaration( Flux::IR::constants::enum_type(), t.name.name, t.is_public, t.is_const ) );
		}
		else {
			throw new NoThankYou "oh no, looks like you've got something weird going on";
		}
	}
}

void State:load_ast_file_header(Parsing::File file) {
	foreach statement in file.header_statements {
		if (statement typeof Flux::Parsing::EnumDefinition) {

		}
		print( "(header) " `concat` statement:serialize() `concat` "\n" );
	}
}

void State:load_ast_file_source(Parsing::File file) {
	foreach statement in file.statements {
		print( statement:serialize() `concat` "\n" );
	}
}

void State:load_ast(Source source) {
	foreach k, file in source.files_included
		self.files[k] = self:initialise_ast_file( file );

	foreach k, file in source.files_included {
		self.active_file = self.files[k];
		self:load_ast_file_types( file );
	}

	foreach k, file in source.files_included {
		self.active_file = self.files[k];
		self:load_ast_file_header( file );
	}

	foreach k, file in source.files_included {
		self.active_file = self.files[k];
		self:load_ast_file_source( file );
	}
}

string State:format_err_msg(string err, Position position)
	= src `concat` "[" `concat` line `concat` "]: " `concat` err `concat` "\n\t"
		`concat` strline `concat` "\n\t"
		`concat` char_pointer
	where src = position.source
	where line = position.line
	where strline = position.strline:gsub( "\t", " " )
	where char_pointer = (" "):rep( position.character - 1 ) `concat` "^";

void State:warn(string err, Position position)
	= print( self:format_err_msg( err, position ) );

void State:error(string err, Position position)
	= throw new ParserException( self:format_err_msg( err, position ) );
