
import references.locations.UpvalueReferenceLocation;
import Parsing.imports.Source;
import File;
import Position;
import Declaration;
import constants;
import definitions.EnumDefinition;
import lookup_utils;
import statements.Statement;

namespace Flux::IR;

class State {
	File{string} files;
	File active_file;
	Scope[] working_scope_stack;

	State() {
		self.files = {};
		self.working_scope_stack = [];
	}

	private:
	void initialise_ast_file(Parsing::File file);
	void load_ast_file_types(Parsing::File file);
	void load_ast_file_header(Parsing::File file);
	void load_ast_file_source(Parsing::File file);

	string format_err_msg(string err, Position pos);

	public:
	void push_scope(bool is_function_scope);
	Scope pop_scope();

	Declaration declare(Declaration decl);

	Reference[] lookup(string name);
	Reference[] lookup_pattern(string name);

	void load_ast(Source source);

	void error(string err, Position position);
	void warn(string err, Position position);
}

void State:initialise_ast_file(Parsing::File file) {
	new Flux::IR::File ir_file( file.name );

	print( "@" `concat` file.name );

	return ir_file;
}

void State:load_ast_file_types(Parsing::File file) {
	foreach t in file.types {
		if t.type == Flux::Parsing::Type.ENUM {
			self:declare( new Flux::IR::Declaration( Flux::IR::constants::enum_type(), t.name.name, t.is_public, true ) );
		}
		else {
			throw new NoThankYou "oh no, looks like you've got something weird going on";
		}
	}

	foreach path in file.imports {
		self.active_file.import_list[#self.active_file.import_list + 1] = self.files[path];
	}
}

void State:load_ast_file_header(Parsing::File file) {
	foreach statement in file.header_statements {
		if (statement typeof Flux::Parsing::EnumDefinition) {

		}

		Node node = Flux::IR::Statement:fromAST( self, statement );

		if node != Flux::IR::Node.nothing
			self.active_file:push( node );

		print( "(header) " `concat` statement:serialize() `concat` "\n" );
	}
}

void State:load_ast_file_source(Parsing::File file) {
	foreach statement in file.statements {
		print( statement:serialize() `concat` "\n" );

		Node node = Flux::IR::Statement:fromAST( self, statement );

		if node != Flux::IR::Node.nothing
			self.active_file:push( node );

		if (statement typeof Flux::Parsing::ReferenceExpression) {
			print( "Looking up " `concat` statement.name.name );

			foreach ref in self:lookup( statement.name.name )
				print( ref:serialize() );
		}
	}
}

void State:push_scope(bool is_function_scope) {
	self.working_scope_stack[#self.working_scope_stack + 1] = new Flux::IR::Scope(
		#self.working_scope_stack == 0 && self.active_file.scope || self.working_scope_stack[#self.working_scope_stack],
		is_function_scope
	);
}

Scope State:pop_scope()
	= table.remove( self.working_scope_stack, #self.working_scope_stack );

Declaration State:declare(Declaration decl) {
	if #self.working_scope_stack > 0
		self.working_scope_stack[#self.working_scope_stack]:declare( decl );
	else
		self.active_file.scope:declare( decl );

	return decl;
}

Reference[] State:lookup(string name) {
	Reference[] references = [];
	bool is_local = true;

	for (int i = #self.working_scope_stack; i > 0; i--) {
		Reference[] scope_refs = self.working_scope_stack[i]:lookup( name, true );

		if #scope_refs > 0 {
			foreach ref in scope_refs {
				if !is_local
					ref.location = new Flux::IR::UpvalueReferenceLocation();

				references[#references + 1] = ref;
			}
		}

		is_local = false;
	}

	foreach v in self.active_file:lookup( name )
		references[#references + 1] = v;

	return references;
}

Reference[] State:lookup_pattern(string name) {
	Reference[] references = [];

	for (int i = #self.working_scope_stack; i > 0; i--) {
		Reference[] scope_refs = self.working_scope_stack[i]:lookup_pattern( name );

		if #scope_refs > 0 {
			foreach ref in scope_refs {
				if !is_local
					ref.location = new Flux::IR::UpvalueReferenceLocation();

				references[#references + 1] = ref;
			}
		}
	}

	foreach v in self.active_file:lookup_pattern( name )
		references[#references + 1] = v;

	return references;
}

void State:load_ast(Source source) {
	foreach k, file in source.files_included
		self.files[k] = self:initialise_ast_file( file );

	foreach k, file in source.files_included {
		self.active_file = self.files[k];
		self:load_ast_file_types( file );
	}

	foreach k, file in source.files_included {
		self.active_file = self.files[k];
		self:load_ast_file_header( file );
	}

	foreach k, file in source.files_included {
		self.active_file = self.files[k];
		self:load_ast_file_source( file );
	}
}

string State:format_err_msg(string err, Position position)
	= src `concat` "[" `concat` line `concat` "]: " `concat` err `concat` "\n\t"
		`concat` strline `concat` "\n\t"
		`concat` char_pointer
	where src = position.source
	where line = position.line
	where strline = position.strline:gsub( "\t", " " )
	where char_pointer = (" "):rep( position.character - 1 ) `concat` "^";

void State:warn(string err, Position position)
	= print( self:format_err_msg( err, position ) );

void State:error(string err, Position position)
	= throw new ParserException( self:format_err_msg( err, position ) );
