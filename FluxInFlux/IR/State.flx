
import Parsing.imports.Source;
import File;
import Position;

namespace Flux::IR;

class State {
	File{string} files;

	State() {
		self.files = {};
	}

	private:
	void initialise_ast_file(Parsing::File file);
	void load_ast_file_types(Parsing::File file);
	void load_ast_file_header(Parsing::File file);
	void load_ast_file_source(Parsing::File file);

	public:

	void load_ast(Source source);

	void error(string err, Position position);
}

void State:initialise_ast_file(Parsing::File file) {
	new Flux::IR::File ir_file( file.name );

	self.files[file.name] = ir_file;

	print( "@" `concat` file.name );
}

void State:load_ast_file_types(Parsing::File file) {
}

void State:load_ast_file_header(Parsing::File file) {
	foreach statement in file.header_statements {
		print( "(header) " `concat` statement:serialize() `concat` "\n" );
	}
}

void State:load_ast_file_source(Parsing::File file) {
	foreach statement in file.statements {
		print( statement:serialize() `concat` "\n" );
	}
}

void State:load_ast(Source source) {
	foreach k, file in source.files_included {
		self:initialise_ast_file( file );
		self:load_ast_file_types( file );
		self:load_ast_file_header( file );
		self:load_ast_file_source( file );
	}
}

void State:error(string err, Position position)
	= throw new ParserException(src `concat` "[" `concat` line `concat` "]: " `concat` err `concat` "\n\t"
		`concat` strline `concat` "\n\t"
		`concat` char_pointer)
	where src = position.source
	where line = position.line
	where strline = position.strline:gsub( "\t", " " )
	where char_pointer = (" "):rep( position.character - 1 ) `concat` "^";
