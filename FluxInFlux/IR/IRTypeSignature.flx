
int{IRTypeComparison} weights = {
	[IRTypeComparison.ExactMatch] = 6;
	[IRTypeComparison.ExactMatchTemplate] = 5;
	[IRTypeComparison.ExtendsFrom] = 4;
	[IRTypeComparison.ExtendsFromTemplate] = 3;
	[IRTypeComparison.CastsTo] = 2;
	[IRTypeComparison.CastsToTemplate] = 1;
	[IRTypeComparison.NoMatch] = 0;
};

IRTypeComparison{int} compare_lookup = {
	[6] = IRTypeComparison.ExactMatch;
	[5] = IRTypeComparison.ExactMatchTemplate;
	[4] = IRTypeComparison.ExtendsFrom;
	[3] = IRTypeComparison.ExtendsFromTemplate;
	[2] = IRTypeComparison.CastsTo;
	[1] = IRTypeComparison.CastsToTemplate;
	[0] = IRTypeComparison.NoMatch;
};

IRTypeSignature IRTypeSignature:fromAST(Flux::Parsing::Type t) {
	// lol no
}

IRTypeComparison IRTypeSignature:compare(IRTypeSignature sig) {
	if self.name == IRDefinitionPointer.auto_type || sig.name == IRDefinitionPointer.auto_type
		return IRTypeComparison.CastsTo;

	if sig.name == IRDefinitionPointer.void_type
		return IRTypeComparison.CastsTo;

	if self.name:definition() typeof IRClassDefinition && sig.name == IRDefinitionPointer.struct_type {
		// struct compare
	}

	if sig.name == IRDefinitionPointer.null_type {
		let compare_internal = self:compare( sig.classes[1] );
		if compare_internal == IRTypeComparison.CastsToTemplate
			return IRTypeComparison.CastsToTemplate;
		else if compare_internal != IRTypeComparison.NoMatch
			return IRTypeComparison.CastsTo;
	}

	if (sig typeof IRTypeSignatureTemplate) {
		int max = 0;

		foreach v in sig.classes
			max = math.max( weights[self:compare( v )], max );

		return compare_lookup[max % 2 == 0 && max > 0 && max - 1 || max];
	}
	else if #self.classes != #sig.classes
		return IRTypeComparison.NoMatch;
	else {
		int min = weights[IRTypeComparison.ExactMatch];

		if self.name:eq( sig.name ) {
			min = weights[IRTypeComparison.ExactMatch];
		}
		else if (self.name:definition() typeof IRClassDefinition && sig.name:definition() typeof IRClassDefinition)
		     && self.name:definition():doesExtend( sig.name ) {
			min = weights[IRTypeComparison.ExtendsFrom];
		}
		else if (self.name:definition() typeof IRClassDefinition && sig.name:definition() typeof IRClassDefinition)
		     && self.name:definition():doesCastTo( sig.name ) {
			min = weights[IRTypeComparison.CastsTo];
		}
		else
			return IRTypeComparison.NoMatch;

		foreach i, v in self.classes
			min = math.min( weights[v:compare( sig.classes[i] )], min );

		return compare_lookup[min];
	}
}

string IRTypeSignature:tostring() {
	string[] s = [];

	foreach i, v in self.classes
		s[i] = v:tostring();

	return self.name:definition().name `concat` "<" `concat` table.concat( s, ", " ) `concat` ">";
}
