
import references.locations.LocalReferenceLocation;
import references.ScopedReference;
import references.GetterReference;
import references.SetterReference;

namespace Flux::IR;

class Scope {
	Declaration[] declarations;
	Scope parent;
	bool is_function_scope;

	Scope(Scope parent, bool is_function_scope) {
		self.parent = parent;
		self.is_function_scope = is_function_scope;

		self.declarations = [];
	}

	Declaration declare(Declaration decl);
	Declaration[] lookup(string name);
	Declaration[] lookup_pattern(string pattern);
}

Declaration Scope:declare(Declaration decl) {
	self.declarations[#self.declarations + 1] = decl;

	return decl;
}

Reference[] Scope:lookup(string name, bool privates, null int upper_index = #self.declarations) {
	Reference[] references = [];

	for (int i = upper_index; i > 0; i--) {
		Declaration decl = self.declarations[i];

		if decl.name == name && (privates || decl.is_public)
			references[#references + 1] = new Flux::IR::ScopedReference( new Flux::IR::LocalReferenceLocation(), self, i );

		else if decl.name == "getter " `concat` name && (privates || decl.is_public)
			references[#references + 1] = new Flux::IR::GetterReference(
				new Flux::IR::ScopedReference(
					new Flux::IR::LocalReferenceLocation(), self, i
				)
			);

		else if decl.name == "setter " `concat` name && (privates || decl.is_public)
			references[#references + 1] = new Flux::IR::SetterReference(
				new Flux::IR::ScopedReference(
					new Flux::IR::LocalReferenceLocation(), self, i
				)
			);
	}

	return references;
}

Reference[] Scope:lookup_pattern(string pattern, bool privates, null int upper_index = #self.declarations) {
	Reference[] references = [];

	for (int i = upper_index; i > 0; i--) {
		Declaration decl = self.declarations[i];

		if decl.name:find( name ) && (privates || decl.is_public)
			references[#references + 1] = new Flux::IR::ScopedReference( new Flux::IR::LocalReferenceLocation(), self, i );
	}

	return references;
}
